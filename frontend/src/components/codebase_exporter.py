#!/usr/bin/env python3
"""
Optimized Codebase Extractor for Django + React Projects
Extracts only project-relevant code, skipping framework boilerplate.
"""

import os
import re
from pathlib import Path
from datetime import datetime
from typing import Optional, Set, List, Dict
import hashlib


# ============================================================
# CONFIGURATION - Django & React Specific
# ============================================================

DJANGO_BOILERPLATE_FILES = {
    'manage.py', 'wsgi.py', 'asgi.py', 'apps.py',
    'conftest.py', 'pytest.ini', 'setup.cfg',
}

DJANGO_BOILERPLATE_DIRS = {
    'migrations', '__pycache__', '.git', '.venv', 'venv',
    'env', 'staticfiles', 'static/admin', 'media',
    '.pytest_cache', '.mypy_cache', 'htmlcov', '.tox',
    'site-packages', 'egg-info', '.eggs',
}

REACT_BOILERPLATE_FILES = {
    'reportWebVitals.js', 'reportWebVitals.ts',
    'setupTests.js', 'setupTests.ts',
    'serviceWorker.js', 'service-worker.js',
    'react-app-env.d.ts', 'logo.svg',
    'App.test.js', 'App.test.tsx',
    'favicon.ico', 'manifest.json', 'robots.txt',
}

REACT_BOILERPLATE_DIRS = {
    'node_modules', 'build', 'dist', 'coverage',
    '.next', '.nuxt', 'out', '.cache',
}

# Files to ALWAYS exclude (binary, locks, configs)
ALWAYS_EXCLUDE_FILES = {
    '.DS_Store', 'Thumbs.db', '.gitignore', '.gitattributes',
    'package-lock.json', 'yarn.lock', 'pnpm-lock.yaml',
    'poetry.lock', 'Pipfile.lock', 'requirements.txt',
    '.env', '.env.local', '.env.development', '.env.production',
    'docker-compose.yml', 'Dockerfile', '.dockerignore',
    '.prettierrc', '.eslintrc', '.eslintrc.js', '.eslintrc.json',
    'tsconfig.json', 'jsconfig.json', 'babel.config.js',
    '.babelrc', 'webpack.config.js', 'vite.config.js',
    'tailwind.config.js', 'postcss.config.js',
    'jest.config.js', 'jest.config.ts',
}

ALWAYS_EXCLUDE_EXTENSIONS = {
    '.pyc', '.pyo', '.exe', '.dll', '.so', '.dylib',
    '.png', '.jpg', '.jpeg', '.gif', '.ico', '.svg', '.webp',
    '.woff', '.woff2', '.ttf', '.eot', '.otf',
    '.mp3', '.mp4', '.wav', '.avi', '.mov',
    '.pdf', '.doc', '.docx', '.xls', '.xlsx',
    '.zip', '.tar', '.gz', '.rar', '.7z',
    '.sqlite3', '.db', '.log', '.map',
}

# Patterns indicating boilerplate content
BOILERPLATE_PATTERNS = [
    r'^# Generated by Django',
    r'^// This file was auto-generated',
    r'from django\.contrib import admin\s*\n\s*# Register your models here\.\s*$',
    r'^from django\.test import TestCase\s*\n\s*# Create your tests here\.\s*$',
    r'^from django\.shortcuts import render\s*\n\s*# Create your views here\.\s*$',
    r'^from django\.db import models\s*\n\s*# Create your models here\.\s*$',
    r'ReactDOM\.(render|createRoot).*<App\s*/?>.*',
]


class CodebaseExtractor:
    """Efficient codebase extractor for Django + React projects."""
    
    def __init__(
        self,
        root_dir: str = ".",
        output_file: str = "codebase_contents.txt",
        max_file_size: int = 100 * 1024,  # 100KB default (reduced)
        include_tests: bool = False,
        include_configs: bool = False,
        compact_mode: bool = True,
    ):
        self.root_path = Path(root_dir).resolve()
        self.output_file = output_file
        self.max_file_size = max_file_size
        self.include_tests = include_tests
        self.include_configs = include_configs
        self.compact_mode = compact_mode
        
        # Stats
        self.stats = {
            'included': 0,
            'skipped_boilerplate': 0,
            'skipped_size': 0,
            'skipped_binary': 0,
            'skipped_empty': 0,
        }
        self.skipped_files: List[str] = []
        
        # Build exclusion sets
        self.exclude_dirs = (
            DJANGO_BOILERPLATE_DIRS | 
            REACT_BOILERPLATE_DIRS | 
            {'.git', '.idea', '.vscode'}
        )
        self.exclude_files = (
            DJANGO_BOILERPLATE_FILES | 
            REACT_BOILERPLATE_FILES | 
            ALWAYS_EXCLUDE_FILES |
            {output_file}
        )
    
    def extract(self) -> None:
        """Main extraction method."""
        with open(self.output_file, 'w', encoding='utf-8') as out:
            self._write_header(out)
            self._write_structure(out)
            self._write_contents(out)
            self._write_summary(out)
        
        self._print_stats()
    
    def _write_header(self, out) -> None:
        """Write minimal header."""
        out.write(f"# CODEBASE: {self.root_path.name}\n")
        out.write(f"# Generated: {datetime.now().strftime('%Y-%m-%d %H:%M')}\n")
        out.write("=" * 60 + "\n\n")
    
    def _write_structure(self, out) -> None:
        """Write compact directory structure."""
        out.write("## STRUCTURE\n")
        out.write("-" * 30 + "\n")
        
        for line in self._generate_tree():
            out.write(line + "\n")
        out.write("\n")
    
    def _generate_tree(self) -> List[str]:
        """Generate compact tree structure."""
        lines = [f"{self.root_path.name}/"]
        self._add_tree_level(self.root_path, "", lines)
        return lines
    
    def _add_tree_level(self, path: Path, prefix: str, lines: List[str]) -> None:
        """Recursively add tree levels."""
        try:
            entries = sorted(
                [e for e in path.iterdir() if not self._should_exclude_from_tree(e)],
                key=lambda x: (x.is_file(), x.name.lower())
            )
        except PermissionError:
            return
        
        for i, entry in enumerate(entries):
            is_last = i == len(entries) - 1
            connector = "â””â”€ " if is_last else "â”œâ”€ "
            
            if entry.is_dir():
                lines.append(f"{prefix}{connector}{entry.name}/")
                extension = "   " if is_last else "â”‚  "
                self._add_tree_level(entry, prefix + extension, lines)
            else:
                # Mark important files
                marker = self._get_file_marker(entry)
                lines.append(f"{prefix}{connector}{entry.name}{marker}")
    
    def _get_file_marker(self, path: Path) -> str:
        """Get marker for file importance."""
        name = path.name.lower()
        
        # High importance Django files
        if name in ('models.py', 'views.py', 'urls.py', 'serializers.py', 'forms.py'):
            return " *"
        # High importance React files
        if name.endswith(('.jsx', '.tsx')) and 'test' not in name.lower():
            return " *"
        # Settings/config
        if 'settings' in name or name == 'urls.py':
            return " !"
        return ""
    
    def _should_exclude_from_tree(self, path: Path) -> bool:
        """Check if path should be excluded from tree."""
        if path.is_dir():
            return path.name in self.exclude_dirs
        return path.suffix.lower() in ALWAYS_EXCLUDE_EXTENSIONS
    
    def _write_contents(self, out) -> None:
        """Write file contents."""
        out.write("=" * 60 + "\n")
        out.write("## FILES\n")
        out.write("=" * 60 + "\n")
        
        for file_path in self._get_project_files():
            self._process_file(file_path, out)
    
    def _get_project_files(self):
        """Get all relevant project files."""
        for item in sorted(self.root_path.rglob("*")):
            if item.is_file() and self._should_include(item):
                yield item
    
    def _should_include(self, path: Path) -> bool:
        """Determine if file should be included."""
        name = path.name
        suffix = path.suffix.lower()
        rel_path = str(path.relative_to(self.root_path))
        
        # Always exclude these extensions
        if suffix in ALWAYS_EXCLUDE_EXTENSIONS:
            return False
        
        # Check if in excluded directory
        for parent in path.parents:
            if parent.name in self.exclude_dirs:
                return False
        
        # Check excluded files
        if name in self.exclude_files:
            self.skipped_files.append(f"{rel_path} (boilerplate)")
            self.stats['skipped_boilerplate'] += 1
            return False
        
        # Skip test files unless requested
        if not self.include_tests:
            if 'test' in name.lower() or '/tests/' in rel_path or '\\tests\\' in rel_path:
                self.skipped_files.append(f"{rel_path} (test file)")
                return False
        
        # Skip __init__.py if empty or minimal
        if name == '__init__.py':
            try:
                content = path.read_text(encoding='utf-8', errors='ignore')
                if len(content.strip()) < 50:  # Nearly empty
                    return False
            except:
                return False
        
        return True
    
    def _process_file(self, file_path: Path, out) -> None:
        """Process and write a single file."""
        rel_path = file_path.relative_to(self.root_path)
        
        try:
            file_size = file_path.stat().st_size
            
            # Size check
            if file_size > self.max_file_size:
                self.skipped_files.append(f"{rel_path} (size: {file_size//1024}KB)")
                self.stats['skipped_size'] += 1
                return
            
            # Empty file check
            if file_size == 0:
                self.stats['skipped_empty'] += 1
                return
            
            # Read content
            content = self._read_file(file_path)
            if content is None:
                self.stats['skipped_binary'] += 1
                self.skipped_files.append(f"{rel_path} (binary)")
                return
            
            # Check if boilerplate content
            if self._is_boilerplate_content(content, file_path):
                self.skipped_files.append(f"{rel_path} (boilerplate content)")
                self.stats['skipped_boilerplate'] += 1
                return
            
            # Process content
            processed_content = self._process_content(content, file_path)
            
            # Write to output
            self._write_file_section(out, rel_path, processed_content, file_size)
            self.stats['included'] += 1
            
        except Exception as e:
            self.skipped_files.append(f"{rel_path} (error: {str(e)[:30]})")
    
    def _read_file(self, file_path: Path) -> Optional[str]:
        """Read file with encoding detection."""
        # Quick binary check
        try:
            with open(file_path, 'rb') as f:
                chunk = f.read(1024)
                if b'\x00' in chunk:
                    return None
        except:
            return None
        
        # Try reading as text
        for encoding in ['utf-8', 'utf-8-sig', 'latin-1']:
            try:
                return file_path.read_text(encoding=encoding)
            except UnicodeDecodeError:
                continue
            except Exception:
                return None
        return None
    
    def _is_boilerplate_content(self, content: str, file_path: Path) -> bool:
        """Check if content is boilerplate."""
        content_stripped = content.strip()
        
        # Very short files with only imports
        if len(content_stripped) < 100:
            lines = [l.strip() for l in content_stripped.split('\n') if l.strip()]
            if all(l.startswith(('import ', 'from ', '#', '//', '/*', '*')) for l in lines):
                return True
        
        # Check against known patterns
        for pattern in BOILERPLATE_PATTERNS:
            if re.search(pattern, content_stripped, re.MULTILINE | re.DOTALL):
                return True
        
        # Django default admin.py
        if file_path.name == 'admin.py':
            if 'admin.site.register' not in content and len(content_stripped) < 200:
                return True
        
        # React index.js/tsx that just exports
        if file_path.name in ('index.js', 'index.ts', 'index.jsx', 'index.tsx'):
            if content_stripped.startswith('export') and len(content_stripped) < 100:
                return True
        
        return False
    
    def _process_content(self, content: str, file_path: Path) -> str:
        """Process content for compactness."""
        if not self.compact_mode:
            return content
        
        lines = content.split('\n')
        processed_lines = []
        consecutive_empty = 0
        in_docstring = False
        
        for line in lines:
            stripped = line.strip()
            
            # Track docstrings (keep first line only)
            if '"""' in stripped or "'''" in stripped:
                if stripped.count('"""') == 2 or stripped.count("'''") == 2:
                    # Single line docstring - keep it
                    processed_lines.append(line)
                    continue
                in_docstring = not in_docstring
                if in_docstring:
                    processed_lines.append(line)
                continue
            
            if in_docstring:
                continue  # Skip docstring content
            
            # Skip excessive comments (keep important ones)
            if stripped.startswith('#') or stripped.startswith('//'):
                if any(kw in stripped.lower() for kw in ['todo', 'fixme', 'note:', 'important', 'hack']):
                    processed_lines.append(line)
                continue
            
            # Collapse multiple empty lines
            if not stripped:
                consecutive_empty += 1
                if consecutive_empty <= 1:
                    processed_lines.append('')
                continue
            else:
                consecutive_empty = 0
            
            processed_lines.append(line)
        
        return '\n'.join(processed_lines)
    
    def _write_file_section(self, out, rel_path: Path, content: str, size: int) -> None:
        """Write file section in compact format."""
        if self.compact_mode:
            out.write(f"\n### {rel_path}\n")
            out.write(f"```{self._get_language(rel_path)}\n")
            out.write(content.rstrip())
            out.write("\n```\n")
        else:
            out.write(f"\n{'='*60}\n")
            out.write(f"FILE: {rel_path} ({size}B)\n")
            out.write("-" * 60 + "\n")
            out.write(content)
            if not content.endswith('\n'):
                out.write('\n')
    
    def _get_language(self, path: Path) -> str:
        """Get language for syntax highlighting."""
        ext_map = {
            '.py': 'python',
            '.js': 'javascript',
            '.jsx': 'jsx',
            '.ts': 'typescript',
            '.tsx': 'tsx',
            '.html': 'html',
            '.css': 'css',
            '.scss': 'scss',
            '.json': 'json',
            '.yaml': 'yaml',
            '.yml': 'yaml',
            '.md': 'markdown',
            '.sql': 'sql',
            '.sh': 'bash',
        }
        return ext_map.get(path.suffix.lower(), '')
    
    def _write_summary(self, out) -> None:
        """Write extraction summary."""
        out.write(f"\n{'='*60}\n")
        out.write("## SUMMARY\n")
        out.write(f"- Files included: {self.stats['included']}\n")
        out.write(f"- Skipped (boilerplate): {self.stats['skipped_boilerplate']}\n")
        out.write(f"- Skipped (size): {self.stats['skipped_size']}\n")
        out.write(f"- Skipped (binary): {self.stats['skipped_binary']}\n")
        
        if self.skipped_files:
            out.write("\n### Skipped Files:\n")
            for f in self.skipped_files[:50]:  # Limit to 50
                out.write(f"  - {f}\n")
            if len(self.skipped_files) > 50:
                out.write(f"  ... and {len(self.skipped_files) - 50} more\n")
    
    def _print_stats(self) -> None:
        """Print extraction statistics."""
        print(f"\nâœ… Extracted to: {self.output_file}")
        print(f"ðŸ“ Files included: {self.stats['included']}")
        print(f"â­ï¸  Skipped: {sum(v for k, v in self.stats.items() if k != 'included')}")
        
        # Show file size
        size = Path(self.output_file).stat().st_size
        if size > 1024 * 1024:
            print(f"ðŸ“¦ Output size: {size / (1024*1024):.2f} MB")
        else:
            print(f"ðŸ“¦ Output size: {size / 1024:.2f} KB")


def main():
    import argparse
    
    parser = argparse.ArgumentParser(
        description="Extract Django + React codebase (smart filtering)"
    )
    parser.add_argument(
        "-d", "--directory", 
        default=".", 
        help="Root directory"
    )
    parser.add_argument(
        "-o", "--output", 
        default="codebase_contents.txt", 
        help="Output file"
    )
    parser.add_argument(
        "--max-size", 
        type=int, 
        default=100, 
        help="Max file size in KB (default: 100)"
    )
    parser.add_argument(
        "--include-tests", 
        action="store_true", 
        help="Include test files"
    )
    parser.add_argument(
        "--include-configs", 
        action="store_true", 
        help="Include config files"
    )
    parser.add_argument(
        "--no-compact", 
        action="store_true", 
        help="Disable compact mode (keep comments/docstrings)"
    )
    
    args = parser.parse_args()
    
    extractor = CodebaseExtractor(
        root_dir=args.directory,
        output_file=args.output,
        max_file_size=args.max_size * 1024,
        include_tests=args.include_tests,
        include_configs=args.include_configs,
        compact_mode=not args.no_compact,
    )
    
    extractor.extract()


if __name__ == "__main__":
    main()