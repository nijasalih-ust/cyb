# CODEBASE: backend
# Generated: 2025-12-28 17:28
============================================================

## STRUCTURE
------------------------------
backend/
â”œâ”€ api/
â”‚  â”œâ”€ management/
â”‚  â”‚  â”œâ”€ commands/
â”‚  â”‚  â”‚  â”œâ”€ __init__.py
â”‚  â”‚  â”‚  â”œâ”€ link_lessons_techniques.py
â”‚  â”‚  â”‚  â”œâ”€ seed_mitre_framework.py
â”‚  â”‚  â”‚  â”œâ”€ seed_mitre_from_file.py
â”‚  â”‚  â”‚  â””â”€ seed_mitre_offline.py
â”‚  â”‚  â””â”€ __init__.py
â”‚  â”œâ”€ __init__.py
â”‚  â”œâ”€ admin.py
â”‚  â”œâ”€ apps.py
â”‚  â”œâ”€ models.py *
â”‚  â”œâ”€ seed.py
â”‚  â”œâ”€ serializers.py *
â”‚  â”œâ”€ tests.py
â”‚  â”œâ”€ urls.py *
â”‚  â””â”€ views.py *
â”œâ”€ backend/
â”‚  â”œâ”€ __init__.py
â”‚  â”œâ”€ asgi.py
â”‚  â”œâ”€ requirement.txt
â”‚  â”œâ”€ settings.py !
â”‚  â”œâ”€ urls.py *
â”‚  â””â”€ wsgi.py
â”œâ”€ scripts/
â”‚  â””â”€ seed_framework.py
â”œâ”€ sql/
â”‚  â””â”€ chema.sql
â”œâ”€ .env
â”œâ”€ check_relationships.py
â”œâ”€ check_users.py
â”œâ”€ codebase_contents.txt
â”œâ”€ codebase_exporter.py
â”œâ”€ create_analyst_user.py
â”œâ”€ debug_out_utf8.txt
â”œâ”€ debug_output.txt
â”œâ”€ debug_views.py
â”œâ”€ manage.py
â”œâ”€ test_api.py
â”œâ”€ test_lessons_with_techniques.py
â”œâ”€ test_navigator.py
â””â”€ test_nested_data.py

============================================================
## FILES
============================================================

### api\management\commands\link_lessons_techniques.py
```python
"""
import re
from django.core.management.base import BaseCommand
from api.models import Lesson, MitreTechnique, LessonTechniqueMap

MITRE_ID_RE = re.compile(r"\bT\d{4}(?:\.\d+)?\b", re.IGNORECASE)

class Command(BaseCommand):
    help = 'Automatically link Lesson objects to MitreTechnique objects'

    def handle(self, *args, **options):
        lessons = Lesson.objects.all()
        total_created = 0
        report = []

        techniques_by_id = {t.mitre_id.upper(): t for t in MitreTechnique.objects.all()}
        techniques_list = list(MitreTechnique.objects.all())

        for lesson in lessons:
            texts = ' '.join(filter(None, [getattr(lesson, 'title', ''), getattr(lesson, 'description', ''), getattr(lesson, 'key_indicators', ''), getattr(lesson, 'router_link', '')]))
            if not texts.strip():
                continue
            texts_lower = texts.lower()

            created_for_lesson = 0
            linked = set()

            for match in MITRE_ID_RE.findall(texts):
                mid = match.upper()
                tech = techniques_by_id.get(mid)
                if tech and tech.id not in linked:
                    obj, created = LessonTechniqueMap.objects.get_or_create(lesson=lesson, technique=tech)
                    if created:
                        created_for_lesson += 1
                    linked.add(tech.id)

            for tech in techniques_list:
                name = (tech.name or '').lower()
                if len(name) < 6:
                    continue
                name_tokens = re.split(r"\W+", name)
                for token in name_tokens:
                    if not token or len(token) < 4:
                        continue
                    if re.search(r"\b" + re.escape(token) + r"\b", texts_lower):
                        if tech.id not in linked:
                            obj, created = LessonTechniqueMap.objects.get_or_create(lesson=lesson, technique=tech)
                            if created:
                                created_for_lesson += 1
                            linked.add(tech.id)
                        break

            if created_for_lesson:
                report.append((lesson.router_link or lesson.title, created_for_lesson))
                total_created += created_for_lesson

        self.stdout.write(self.style.SUCCESS(f'Linking complete: {total_created} new LessonTechniqueMap entries created'))
        if report:
            for item, count in report:
                self.stdout.write(f'  {item}: {count} new links')
        else:
            self.stdout.write('  No new links created')
```

### api\management\commands\seed_mitre_framework.py
```python
"""

from django.core.management.base import BaseCommand, CommandError
from api.models import KillChainPhase, MitreTactic, MitreTechnique, TacticPhaseMap

class Command(BaseCommand):
    help = "Seed MITRE ATT&CK framework data from official TAXII server"

    def add_arguments(self, parser):
        parser.add_argument(
            '--skip-network',
            action='store_true',
            help='Skip network fetch; only ensure kill chain phases exist',
        )

    def handle(self, *args, **options):
        self.stdout.write(self.style.SUCCESS('ðŸš€ Starting MITRE framework seeder'))

        self._seed_kill_chain_phases()

        if not options['skip_network']:
            try:
                self._fetch_and_seed_from_taxii()
            except Exception as e:
                self.stdout.write(
                    self.style.WARNING(f'âš ï¸  TAXII fetch failed (network issue?): {e}')
                )
                self.stdout.write(self.style.WARNING('Continuing with existing data...'))
        else:
            self.stdout.write(self.style.WARNING('Skipping network fetch (--skip-network)'))

        self.stdout.write(self.style.SUCCESS('âœ… MITRE framework seeding complete'))

    def _seed_kill_chain_phases(self):
        """Ensure kill chain phases 1-7 exist."""
        phases_data = [
            (1, 'Reconnaissance', 'Planning and research.'),
            (2, 'Weaponization', 'Preparation of tools.'),
            (3, 'Delivery', 'Transmission to target.'),
            (4, 'Exploitation', 'Triggering the weapon.'),
            (5, 'Installation', 'Establishing persistence.'),
            (6, 'Command and Control', 'Remote manipulation.'),
            (7, 'Actions on Objectives', 'Data theft or destruction.'),
        ]

        created = 0
        for step, name, desc in phases_data:
            obj, is_new = KillChainPhase.objects.update_or_create(
                step_number=step,
                defaults={'name': name, 'description': desc}
            )
            if is_new:
                created += 1

        self.stdout.write(f'  Kill Chain Phases: {created} created/updated')

    def _fetch_and_seed_from_taxii(self):
        """Fetch MITRE ATT&CK from TAXII and seed database."""
        import ssl
        import urllib3
        from taxii2client.v21 import Server
        from stix2 import TAXIICollectionSource, Filter

        urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
        ssl_verify = False

        self.stdout.write('  Connecting to MITRE TAXII server...')
        server = Server('https://cti-taxii.mitre.org/stix/collections/', verify=ssl_verify)
        api_roots = server.api_roots
        if not api_roots:
            raise RuntimeError('No API roots found on TAXII server')

        api_root = api_roots[0]

        collection = None
        for c in api_root.collections:
            title = getattr(c, 'title', '') or getattr(c, 'id', '')
            if 'Enterprise' in title or 'enterprise-attack' in title.lower():
                collection = c
                break
        if not collection:
            collection = api_root.collections[0]

        src = TAXIICollectionSource(collection)

        self.stdout.write('  Fetching MITRE tactics and techniques...')
        tactics = list(src.query(Filter('type', '=', 'x-mitre-tactic')))
        techniques = list(src.query([
            Filter('type', '=', 'attack-pattern'),
            Filter('revoked', '!=', True)
        ]))

        self.stdout.write(f'  Fetched {len(tactics)} tactics and {len(techniques)} techniques')

        tactic_short_to_dbid = {}

        self.stdout.write('  Seeding tactics...')
        tactics_created = 0
        for t in tactics:
            mitre_id = None
            for ref in getattr(t, 'external_references', []) or []:
                if getattr(ref, 'source_name', '') == 'mitre-attack':
                    mitre_id = getattr(ref, 'external_id', None)
                    if mitre_id:
                        break
            if not mitre_id:
                continue

            name = getattr(t, 'name', mitre_id)
            shortname = getattr(t, 'x_mitre_shortname', None) or name.lower().replace(' ', '-')

            obj, is_new = MitreTactic.objects.update_or_create(
                mitre_id=mitre_id,
                defaults={'name': name}
            )
            if is_new:
                tactics_created += 1
            tactic_short_to_dbid[shortname] = obj.id

            phase_key = shortname.lower()
            phase_mapping = {
                'reconnaissance': 1,
                'resource-development': 2,
                'initial-access': 3,
                'execution': 4,
                'persistence': 5,
                'privilege-escalation': 4,
                'defense-evasion': 5,
                'credential-access': 6,
                'discovery': 1,
                'lateral-movement': 6,
                'command-and-control': 6,
                'exfiltration': 7,
                'impact': 7,
            }
            phase_num = phase_mapping.get(phase_key) or phase_mapping.get(name.lower())
            if phase_num:
                phase = KillChainPhase.objects.filter(step_number=phase_num).first()
                if phase:
                    TacticPhaseMap.objects.update_or_create(
                        tactic=obj,
                        phase=phase,
                        defaults={}
                    )

        self.stdout.write(f'    {tactics_created} tactics created')

        self.stdout.write('  Seeding techniques...')
        techniques_created = 0
        for tech in techniques:
            mitre_id = None
            for ref in getattr(tech, 'external_references', []) or []:
                if getattr(ref, 'source_name', '') == 'mitre-attack':
                    mitre_id = getattr(ref, 'external_id', None)
                    if mitre_id:
                        break
            if not mitre_id:
                continue

            name = getattr(tech, 'name', mitre_id)
            desc = getattr(tech, 'description', '')

            primary_tactic = None

            for kcp in getattr(tech, 'kill_chain_phases', []) or []:
                phase_name = kcp.get('phase_name', '').lower() if isinstance(kcp, dict) else getattr(kcp, 'phase_name', '').lower()
                if phase_name in tactic_short_to_dbid:
                    primary_tactic = MitreTactic.objects.filter(id=tactic_short_to_dbid[phase_name]).first()
                    break

            if not primary_tactic:
                x_tactics = getattr(tech, 'x_mitre_tactics', []) or []
                for xt in x_tactics:
                    key = xt.lower().replace(' ', '-') if isinstance(xt, str) else str(xt).lower().replace(' ', '-')
                    if key in tactic_short_to_dbid:
                        primary_tactic = MitreTactic.objects.filter(id=tactic_short_to_dbid[key]).first()
                        if primary_tactic:
                            break

            if not primary_tactic and tactic_short_to_dbid:
                first_id = list(tactic_short_to_dbid.values())[0]
                primary_tactic = MitreTactic.objects.filter(id=first_id).first()

            if primary_tactic:
                obj, is_new = MitreTechnique.objects.update_or_create(
                    mitre_id=mitre_id,
                    defaults={
                        'name': name,
                        'description': desc,
                        'tactic': primary_tactic
                    }
                )
                if is_new:
                    techniques_created += 1

        self.stdout.write(f'    {techniques_created} techniques created')
```

### api\management\commands\seed_mitre_from_file.py
```python
"""

import os
import json
from django.core.management.base import BaseCommand
from django.conf import settings
from api.models import KillChainPhase, MitreTactic, MitreTechnique, TacticPhaseMap

class Command(BaseCommand):
    help = 'Seed MITRE ATT&CK from local enterprise-attack.json'

    def add_arguments(self, parser):
        parser.add_argument('--file', dest='file', default='../enterprise-attack.json', help='Path to enterprise-attack.json (relative to backend/)')

    def _seed_kill_chain_phases(self):
        """Ensure kill chain phases 1-7 exist."""
        phases_data = [
            (1, 'Reconnaissance', 'Planning and research.'),
            (2, 'Weaponization', 'Preparation of tools.'),
            (3, 'Delivery', 'Transmission to target.'),
            (4, 'Exploitation', 'Triggering the weapon.'),
            (5, 'Installation', 'Establishing persistence.'),
            (6, 'Command and Control', 'Remote manipulation.'),
            (7, 'Actions on Objectives', 'Data theft or destruction.'),
        ]

        created = 0
        for step, name, desc in phases_data:
            obj, is_new = KillChainPhase.objects.update_or_create(
                step_number=step,
                defaults={'name': name, 'description': desc}
            )
            if is_new:
                created += 1

        self.stdout.write(self.style.NOTICE(f'  Kill Chain Phases ensured: {created} created/updated'))

    def handle(self, *args, **options):
        file_path = options['file']
        if not os.path.isabs(file_path):
            file_path = os.path.normpath(os.path.join(os.getcwd(), file_path))

        if not os.path.exists(file_path):
            raise FileNotFoundError(f'File not found: {file_path}')

        self.stdout.write(self.style.NOTICE(f'Loading STIX bundle from {file_path}'))
        with open(file_path, 'r', encoding='utf-8') as fh:
            data = json.load(fh)

        objects = data.get('objects') or []

        self._seed_kill_chain_phases()

        tactics = [o for o in objects if o.get('type') == 'x-mitre-tactic']
        techniques = [o for o in objects if o.get('type') == 'attack-pattern' and not o.get('revoked')]

        self.stdout.write(self.style.NOTICE(f'Found {len(tactics)} tactics and {len(techniques)} techniques in file'))

        tactic_short_map = {}

        tactic_to_phase = {
            'reconnaissance': 1,
            'resource-development': 2,
            'initial-access': 3,
            'execution': 4,
            'persistence': 5,
            'privilege-escalation': 4,
            'defense-evasion': 5,
            'credential-access': 6,
            'discovery': 1,
            'lateral-movement': 6,
            'command-and-control': 6,
            'exfiltration': 7,
            'impact': 7,
            'collection': 5,
        }

        tactics_created = 0
        for t in tactics:
            mitre_id = None
            for ref in t.get('external_references', []) or []:
                if ref.get('source_name') == 'mitre-attack' and ref.get('external_id'):
                    mitre_id = ref.get('external_id')
                    break
            if not mitre_id:
                continue
            name = t.get('name') or mitre_id
            short = t.get('x_mitre_shortname') or name.lower().replace(' ', '-')

            obj, created = MitreTactic.objects.update_or_create(mitre_id=mitre_id, defaults={'name': name})
            if created:
                tactics_created += 1
            tactic_short_map[short] = obj

            phase_num = tactic_to_phase.get(short) or tactic_to_phase.get(name.lower())
            if phase_num:
                phase = KillChainPhase.objects.filter(step_number=phase_num).first()
                if phase:
                    TacticPhaseMap.objects.update_or_create(tactic=obj, phase=phase, defaults={})

        self.stdout.write(self.style.SUCCESS(f'  Tactics created/updated: {tactics_created}'))

        techniques_created = 0
        techniques_skipped = 0
        for tech in techniques:
            mitre_id = None
            for ref in tech.get('external_references', []) or []:
                if ref.get('source_name') == 'mitre-attack' and ref.get('external_id'):
                    mitre_id = ref.get('external_id')
                    break
            if not mitre_id:
                techniques_skipped += 1
                continue

            name = tech.get('name') or mitre_id
            desc = tech.get('description') or ''

            primary_tactic = None
            for kcp in tech.get('kill_chain_phases', []) or []:
                phase_name = kcp.get('phase_name') if isinstance(kcp, dict) else None
                if phase_name:
                    key = phase_name.lower()
                    if key in tactic_short_map:
                        primary_tactic = tactic_short_map[key]
                        break
            if not primary_tactic:
                for xt in tech.get('x_mitre_tactics', []) or []:
                    key = xt.lower().replace(' ', '-')
                    if key in tactic_short_map:
                        primary_tactic = tactic_short_map[key]
                        break

            if not primary_tactic and tactic_short_map:
                primary_tactic = next(iter(tactic_short_map.values()))

            if not primary_tactic:
                techniques_skipped += 1
                continue

            obj, created = MitreTechnique.objects.update_or_create(
                mitre_id=mitre_id,
                defaults={'name': name, 'description': desc, 'tactic': primary_tactic}
            )
            if created:
                techniques_created += 1

        self.stdout.write(self.style.SUCCESS(f'  Techniques created: {techniques_created}, skipped: {techniques_skipped}'))

        total_tactics = MitreTactic.objects.count()
        total_techniques = MitreTechnique.objects.count()
        self.stdout.write(self.style.SUCCESS(f'Total tactics in DB: {total_tactics}'))
        self.stdout.write(self.style.SUCCESS(f'Total techniques in DB: {total_techniques}'))
```

### api\management\commands\seed_mitre_offline.py
```python
"""

from django.core.management.base import BaseCommand
from api.models import KillChainPhase, MitreTactic, MitreTechnique, TacticPhaseMap

class Command(BaseCommand):
    help = "Seed MITRE ATT&CK framework data from hardcoded offline data (no network required)"

    def handle(self, *args, **options):
        self.stdout.write(self.style.SUCCESS('ðŸš€ Starting offline MITRE framework seeder'))

        self._seed_kill_chain_phases()

        self._seed_tactics_and_techniques()

        self.stdout.write(self.style.SUCCESS('âœ… Offline MITRE framework seeding complete'))

    def _seed_kill_chain_phases(self):
        """Ensure kill chain phases 1-7 exist."""
        phases_data = [
            (1, 'Reconnaissance', 'Planning and research.'),
            (2, 'Weaponization', 'Preparation of tools.'),
            (3, 'Delivery', 'Transmission to target.'),
            (4, 'Exploitation', 'Triggering the weapon.'),
            (5, 'Installation', 'Establishing persistence.'),
            (6, 'Command and Control', 'Remote manipulation.'),
            (7, 'Actions on Objectives', 'Data theft or destruction.'),
        ]

        created = 0
        for step, name, desc in phases_data:
            obj, is_new = KillChainPhase.objects.update_or_create(
                step_number=step,
                defaults={'name': name, 'description': desc}
            )
            if is_new:
                created += 1

        self.stdout.write(f'  Kill Chain Phases: {created} created/updated')

    def _seed_tactics_and_techniques(self):
        """Seed comprehensive MITRE tactics and techniques from hardcoded data."""

        tactics_data = [
            ('TA0043', 'reconnaissance', 'Reconnaissance', 1),
            ('TA0042', 'resource-development', 'Resource Development', 2),
            ('TA0001', 'initial-access', 'Initial Access', 3),
            ('TA0002', 'execution', 'Execution', 4),
            ('TA0003', 'persistence', 'Persistence', 5),
            ('TA0004', 'privilege-escalation', 'Privilege Escalation', 4),
            ('TA0005', 'defense-evasion', 'Defense Evasion', 5),
            ('TA0006', 'credential-access', 'Credential Access', 6),
            ('TA0007', 'discovery', 'Discovery', 1),
            ('TA0008', 'lateral-movement', 'Lateral Movement', 6),
            ('TA0011', 'command-and-control', 'Command and Control', 6),
            ('TA0010', 'exfiltration', 'Exfiltration', 7),
            ('TA0009', 'collection', 'Collection', 5),
            ('TA0040', 'impact', 'Impact', 7),
        ]

        tactic_map = {}
        tactics_created = 0

        for mitre_id, shortname, name, phase_num in tactics_data:
            obj, is_new = MitreTactic.objects.update_or_create(
                mitre_id=mitre_id,
                defaults={'name': name}
            )
            if is_new:
                tactics_created += 1
            tactic_map[shortname] = obj

            phase = KillChainPhase.objects.filter(step_number=phase_num).first()
            if phase:
                TacticPhaseMap.objects.update_or_create(
                    tactic=obj,
                    phase=phase,
                    defaults={}
                )

        self.stdout.write(f'  Tactics: {tactics_created} created/updated')

        techniques_data = [
            ('T1595', 'Active Scanning', 'Scanning networks and services to identify hosts, ports, services.', 'reconnaissance'),
            ('T1595.002', 'Active Scanning: Find Accessible Content', 'Scanning web applications for accessible content.', 'reconnaissance'),
            ('T1592', 'Gather Victim Host Information', 'Gathering information about targeted host systems.', 'reconnaissance'),
            ('T1598', 'Phishing for Information', 'Sending phishing messages to gather information.', 'reconnaissance'),
            ('T1589', 'Gather Victim Identity Information', 'Identifying information about target identities.', 'reconnaissance'),
            ('T1590', 'Gather Victim Network Information', 'Gathering information about target networks.', 'reconnaissance'),
            ('T1598.004', 'Phishing for Information: Spearphishing Link', 'Sending spear phishing links.', 'reconnaissance'),

            ('T1583', 'Acquire Infrastructure', 'Acquiring infrastructure for later use.', 'resource-development'),
            ('T1583.001', 'Acquire Infrastructure: Domains', 'Registering or acquiring domains.', 'resource-development'),
            ('T1583.002', 'Acquire Infrastructure: DNS', 'Acquiring DNS resources.', 'resource-development'),
            ('T1586', 'Compromise Accounts', 'Compromising user/service accounts.', 'resource-development'),

            ('T1190', 'Exploit Public-Facing Application', 'Exploiting vulnerable public-facing services.', 'initial-access'),
            ('T1566', 'Phishing', 'Sending deceptive messages to users.', 'initial-access'),
            ('T1566.001', 'Phishing: Spearphishing Attachment', 'Phishing with malicious attachments.', 'initial-access'),
            ('T1566.002', 'Phishing: Spearphishing Link', 'Phishing with malicious links.', 'initial-access'),
            ('T1091', 'Replication Through Removable Media', 'Spreading via removable media.', 'initial-access'),
            ('T1199', 'Trusted Relationship', 'Exploiting trusted relationships.', 'initial-access'),
            ('T1200', 'Hardware Additions', 'Installing hardware implants.', 'initial-access'),
            ('T1566.003', 'Phishing: Spearphishing via Service', 'Phishing via third-party services.', 'initial-access'),
            ('T1566.004', 'Phishing: Spearphishing Voice', 'Phishing via voice calls.', 'initial-access'),

            ('T1059', 'Command and Scripting Interpreter', 'Executing commands via interpreters.', 'execution'),
            ('T1059.001', 'Command and Scripting Interpreter: PowerShell', 'Executing PowerShell commands.', 'execution'),
            ('T1059.003', 'Command and Scripting Interpreter: Windows Command Shell', 'Using cmd.exe for command execution.', 'execution'),
            ('T1059.008', 'Command and Scripting Interpreter: Unix Shell', 'Using Unix shells for execution.', 'execution'),
            ('T1203', 'Exploitation for Client Execution', 'Exploiting client software vulnerabilities.', 'execution'),
            ('T1559', 'Inter-Process Communication', 'Using IPC for execution.', 'execution'),
            ('T1053', 'Scheduled Task/Job', 'Using scheduled tasks for execution.', 'execution'),
            ('T1204', 'User Execution', 'Tricking users into execution.', 'execution'),
            ('T1204.001', 'User Execution: Malicious Link', 'User executing malicious links.', 'execution'),
            ('T1204.002', 'User Execution: Malicious File', 'User executing malicious files.', 'execution'),
            ('T1047', 'Windows Management Instrumentation', 'Using WMI for execution.', 'execution'),

            ('T1197', 'BITS Jobs', 'Abusing BITS for persistence.', 'persistence'),
            ('T1547', 'Boot or Logon Autostart Execution', 'Persistence via autostart mechanisms.', 'persistence'),
            ('T1547.001', 'Boot or Logon Autostart Execution: Registry Run Keys', 'Using Registry Run keys.', 'persistence'),
            ('T1547.005', 'Boot or Logon Autostart Execution: Startup Folder', 'Using Startup folder.', 'persistence'),
            ('T1547.014', 'Boot or Logon Autostart Execution: Active Setup', 'Using Active Setup for persistence.', 'persistence'),
            ('T1547.013', 'Boot or Logon Autostart Execution: XDG Autostart', 'Using XDG autostart (Linux).', 'persistence'),
            ('T1547.007', 'Boot or Logon Autostart Execution: Re-opened Applications', 'Persisting via auto-reopened apps.', 'persistence'),
            ('T1547.006', 'Boot or Logon Autostart Execution: Kernel Modules and Extensions', 'Using kernel modules for persistence.', 'persistence'),
            ('T1547.011', 'Boot or Logon Autostart Execution: Plist Modification', 'Modifying plist files (macOS).', 'persistence'),
            ('T1547.012', 'Boot or Logon Autostart Execution: Print Processors', 'Using print processors (Windows).', 'persistence'),
            ('T1547.009', 'Boot or Logon Autostart Execution: Shortcut Modification', 'Modifying shortcuts for persistence.', 'persistence'),
            ('T1547.010', 'Boot or Logon Autostart Execution: Port Monitors', 'Using port monitors (Windows).', 'persistence'),
            ('T1547.008', 'Boot or Logon Autostart Execution: LSASS Driver', 'Using LSASS drivers.', 'persistence'),
            ('T1547.004', 'Boot or Logon Autostart Execution: Winlogon Helper DLL', 'Winlogon persistence.', 'persistence'),
            ('T1547.003', 'Boot or Logon Autostart Execution: Time Provider', 'Using time providers (Windows).', 'persistence'),
            ('T1547.002', 'Boot or Logon Autostart Execution: Authentication Packages', 'Using auth packages (Windows).', 'persistence'),
            ('T1547.015', 'Boot or Logon Autostart Execution: Login Hook', 'Using login hooks (macOS).', 'persistence'),
            ('T1037', 'Boot or Logon Initialization Scripts', 'Using logon scripts for persistence.', 'persistence'),
            ('T1037.001', 'Boot or Logon Initialization Scripts: Logon Script (Windows)', 'Windows logon scripts.', 'persistence'),
            ('T1037.004', 'Boot or Logon Initialization Scripts: RC Scripts', 'RC scripts (Unix).', 'persistence'),
            ('T1037.002', 'Boot or Logon Initialization Scripts: Login Hook', 'Login hooks (macOS).', 'persistence'),
            ('T1037.005', 'Boot or Logon Initialization Scripts: Startup Items', 'Startup items (macOS).', 'persistence'),
            ('T1037.003', 'Boot or Logon Initialization Scripts: Network Logon Script', 'Network logon scripts.', 'persistence'),
            ('T1543', 'Create or Modify System Process', 'Creating/modifying system processes.', 'persistence'),
            ('T1543.003', 'Create or Modify System Process: Windows Service', 'Installing malicious Windows services.', 'persistence'),
            ('T1543.001', 'Create or Modify System Process: Launch Agent', 'Creating launch agents (macOS).', 'persistence'),
            ('T1543.002', 'Create or Modify System Process: Launch Daemon', 'Creating launch daemons (macOS).', 'persistence'),
            ('T1543.004', 'Create or Modify System Process: Launch Daemon', 'Systemd units (Linux).', 'persistence'),
            ('T1547.006', 'Boot or Logon Autostart Execution: Kernel Modules', 'Kernel modules (Linux).', 'persistence'),

            ('T1548', 'Abuse Elevation Control Mechanism', 'Bypassing elevation controls.', 'privilege-escalation'),
            ('T1548.002', 'Abuse Elevation Control Mechanism: Bypass User Account Control', 'Bypassing UAC.', 'privilege-escalation'),
            ('T1548.003', 'Abuse Elevation Control Mechanism: Sudo and Sudo Caching', 'Abusing sudo (Linux).', 'privilege-escalation'),
            ('T1548.004', 'Abuse Elevation Control Mechanism: Elevated Execution with Prompt', 'Prompting for elevated execution.', 'privilege-escalation'),
            ('T1134', 'Access Token Manipulation', 'Manipulating access tokens.', 'privilege-escalation'),
            ('T1547.011', 'Boot or Logon Autostart Execution: Plist Modification', 'Plist persistence (macOS).', 'privilege-escalation'),
            ('T1548.001', 'Abuse Elevation Control Mechanism: Setuid and Setgid', 'Setuid/setgid (Unix).', 'privilege-escalation'),
            ('T1068', 'Exploitation for Privilege Escalation', 'Exploiting kernel vulns for priv esc.', 'privilege-escalation'),
            ('T1548.005', 'Abuse Elevation Control Mechanism: Temporary Elevated Cloud Access', 'Temp cloud escalation.', 'privilege-escalation'),

            ('T1548', 'Abuse Elevation Control Mechanism', 'Bypassing elevation controls.', 'defense-evasion'),
            ('T1548.002', 'Abuse Elevation Control Mechanism: Bypass User Account Control', 'Bypassing UAC (Defense Evasion).', 'defense-evasion'),
            ('T1197', 'BITS Jobs', 'Abusing BITS (Defense Evasion).', 'defense-evasion'),
            ('T1612', 'Build Image on Host', 'Building container images.', 'defense-evasion'),
            ('T1140', 'Deobfuscate/Decode Files or Information', 'Deobfuscating payloads.', 'defense-evasion'),
            ('T1036', 'Masquerading', 'Masking true object identity.', 'defense-evasion'),
            ('T1027', 'Obfuscated Files or Information', 'Using obfuscation/encoding.', 'defense-evasion'),
            ('T1027.001', 'Obfuscated Files or Information: Binary Padding', 'Binary padding for obfuscation.', 'defense-evasion'),
            ('T1027.002', 'Obfuscated Files or Information: Software Packing', 'Software packing.', 'defense-evasion'),
            ('T1027.003', 'Obfuscated Files or Information: Steganography', 'Steganography techniques.', 'defense-evasion'),
            ('T1027.004', 'Obfuscated Files or Information: Compile After Delivery', 'Compiling payloads after delivery.', 'defense-evasion'),
            ('T1027.005', 'Obfuscated Files or Information: Indicator Removal from Tools', 'Removing indicators from tools.', 'defense-evasion'),
            ('T1027.006', 'Obfuscated Files or Information: HTML Smuggling', 'HTML smuggling.', 'defense-evasion'),
            ('T1542', 'Pre-OS Boot', 'Modifying pre-boot mechanisms.', 'defense-evasion'),
            ('T1014', 'Rootkit', 'Installing rootkits.', 'defense-evasion'),
            ('T1218', 'Signed Binary Proxy Execution', 'Misusing signed binaries.', 'defense-evasion'),
            ('T1216', 'Signed Script Proxy Execution', 'Misusing signed scripts.', 'defense-evasion'),
            ('T1216.001', 'Signed Script Proxy Execution: PubPrn', 'PubPrn.vbs abuse.', 'defense-evasion'),
            ('T1535', 'Unused/Unsupported Cloud Regions', 'Using unsupported cloud regions.', 'defense-evasion'),
            ('T1550', 'Use Alternate Authentication Material', 'Using alternate auth material.', 'defense-evasion'),
            ('T1550.001', 'Use Alternate Authentication Material: Application Access Token', 'Using app tokens.', 'defense-evasion'),
            ('T1550.002', 'Use Alternate Authentication Material: Pass the Hash', 'Pass-the-hash attacks.', 'defense-evasion'),
            ('T1550.003', 'Use Alternate Authentication Material: Pass the Ticket', 'Pass-the-ticket (Kerberos).', 'defense-evasion'),
            ('T1550.004', 'Use Alternate Authentication Material: Web Session Cookie', 'Web session cookie reuse.', 'defense-evasion'),
            ('T1078', 'Valid Accounts', 'Using valid credentials.', 'defense-evasion'),
            ('T1197', 'BITS Jobs', 'BITS (Defense Evasion).', 'defense-evasion'),

            ('T1110', 'Brute Force', 'Brute force attacks.', 'credential-access'),
            ('T1110.001', 'Brute Force: Password Guessing', 'Password guessing.', 'credential-access'),
            ('T1110.002', 'Brute Force: Password Spraying', 'Password spraying.', 'credential-access'),
            ('T1110.003', 'Brute Force: Password Cracking', 'Password cracking.', 'credential-access'),
            ('T1110.004', 'Brute Force: Credential Stuffing', 'Credential stuffing.', 'credential-access'),
            ('T1187', 'Forced Authentication', 'Forcing authentication.', 'credential-access'),
            ('T1111', 'Multi-Stage Channels', 'Multi-stage channels for C2.', 'credential-access'),
            ('T1056', 'Input Capture', 'Capturing user input.', 'credential-access'),
            ('T1056.001', 'Input Capture: Keylogging', 'Keylogging attacks.', 'credential-access'),
            ('T1056.002', 'Input Capture: GUI Input Capture', 'GUI input capture.', 'credential-access'),
            ('T1056.003', 'Input Capture: Web Portal Capture', 'Web portal input capture.', 'credential-access'),
            ('T1056.004', 'Input Capture: Credential API Hooking', 'API credential hooking.', 'credential-access'),
            ('T1557', 'Man-in-the-Middle', 'MITM attacks.', 'credential-access'),
            ('T1040', 'Network Sniffing', 'Network sniffing for credentials.', 'credential-access'),
            ('T1111', 'Multi-Factor Authentication Interception', 'MFA interception.', 'credential-access'),
            ('T1556', 'Modify Authentication Process', 'Modifying authentication mechanisms.', 'credential-access'),
            ('T1040', 'Network Sniffing', 'Sniffing network traffic.', 'credential-access'),
            ('T1040', 'Network Sniffing', 'Network sniffing.', 'credential-access'),
            ('T1621', 'Multi-Factor Authentication Request Generation', 'MFA request generation.', 'credential-access'),
            ('T1040', 'Network Sniffing', 'Network traffic sniffing.', 'credential-access'),
            ('T1040', 'Network Sniffing', 'Credential sniffing.', 'credential-access'),
            ('T1040', 'Network Sniffing', 'Network monitoring.', 'credential-access'),
            ('T1557', 'Man-in-the-Middle', 'MITM for cred theft.', 'credential-access'),
            ('T1040', 'Network Sniffing', 'Sniffing for credentials.', 'credential-access'),

            ('T1210', 'Exploitation of Remote Services', 'Exploiting remote services.', 'lateral-movement'),
            ('T1570', 'Lateral Tool Transfer', 'Transferring tools laterally.', 'lateral-movement'),
            ('T1021', 'Remote Services', 'Using remote services for lateral movement.', 'lateral-movement'),
            ('T1021.001', 'Remote Services: Remote Desktop Protocol', 'RDP lateral movement.', 'lateral-movement'),
            ('T1021.002', 'Remote Services: SMB/Windows Admin Shares', 'SMB/admin shares.', 'lateral-movement'),
            ('T1021.003', 'Remote Services: Distributed Component Object Model', 'DCOM lateral movement.', 'lateral-movement'),
            ('T1021.004', 'Remote Services: SSH', 'SSH for lateral movement.', 'lateral-movement'),
            ('T1021.005', 'Remote Services: VNC', 'VNC for lateral movement.', 'lateral-movement'),
            ('T1021.006', 'Remote Services: Windows Remote Management', 'WinRM lateral movement.', 'lateral-movement'),

            ('T1071', 'Application Layer Protocol', 'C2 via app protocols.', 'command-and-control'),
            ('T1071.001', 'Application Layer Protocol: Web Protocols', 'HTTP/HTTPS C2.', 'command-and-control'),
            ('T1071.002', 'Application Layer Protocol: File Transfer Protocols', 'FTP/SFTP C2.', 'command-and-control'),
            ('T1071.003', 'Application Layer Protocol: Mail Protocols', 'SMTP/IMAP C2.', 'command-and-control'),
            ('T1071.004', 'Application Layer Protocol: DNS', 'DNS tunneling C2.', 'command-and-control'),
            ('T1092', 'Communication Through Removable Media', 'C2 via removable media.', 'command-and-control'),
            ('T1001', 'Data Obfuscation', 'Obfuscating C2 traffic.', 'command-and-control'),
            ('T1008', 'Fallback Channels', 'Fallback C2 channels.', 'command-and-control'),
            ('T1105', 'Ingress Tool Transfer', 'Transferring tools to target.', 'command-and-control'),
            ('T1571', 'Non-Standard Port', 'Using non-standard ports.', 'command-and-control'),
            ('T1090', 'Proxy', 'Using proxies for C2.', 'command-and-control'),
            ('T1090.001', 'Proxy: Internal Proxy', 'Internal proxy C2.', 'command-and-control'),
            ('T1090.002', 'Proxy: External Proxy', 'External proxy C2.', 'command-and-control'),
            ('T1090.003', 'Proxy: Multi-proxy', 'Multi-proxy chains.', 'command-and-control'),
            ('T1090.004', 'Proxy: Domain Fronting', 'Domain fronting.', 'command-and-control'),
            ('T1095', 'Non-Application Layer Protocol', 'Non-app layer C2 (ICMP, DNS).', 'command-and-control'),

            ('T1020', 'Automated Exfiltration', 'Automated data exfiltration.', 'exfiltration'),
            ('T1030', 'Data Transfer Size Limits', 'Limiting exfil data size.', 'exfiltration'),
            ('T1048', 'Exfiltration Over Alternative Protocol', 'Non-standard exfil protocols.', 'exfiltration'),
            ('T1041', 'Exfiltration Over C2 Channel', 'Exfil via C2.', 'exfiltration'),
            ('T1011', 'Exfiltration Over Other Network Medium', 'Alternative network exfil.', 'exfiltration'),
            ('T1052', 'Exfiltration Over Physical Medium', 'Physical media exfil.', 'exfiltration'),
            ('T1567', 'Exfiltration Over Web Service', 'Web service exfil.', 'exfiltration'),
            ('T1020', 'Automated Exfiltration', 'Auto-exfil.', 'exfiltration'),
            ('T1537', 'Transfer Data to Cloud Account', 'Cloud account exfil.', 'exfiltration'),

            ('T1123', 'Audio Capture', 'Audio recording.', 'collection'),
            ('T1119', 'Automated Exfiltration', 'Auto-collection.', 'collection'),
            ('T1115', 'Clipboard Data', 'Clipboard capture.', 'collection'),
            ('T1530', 'Data from Cloud Storage', 'Cloud storage collection.', 'collection'),
            ('T1005', 'Data from Local System', 'Local data collection.', 'collection'),
            ('T1039', 'Data from Network Shared Drive', 'Shared drive collection.', 'collection'),
            ('T1213', 'Data from Information Repositories', 'Repo collection.', 'collection'),
            ('T1005', 'Data Staged', 'Data staging.', 'collection'),
            ('T1123', 'Audio Capture', 'Audio recording (Collection).', 'collection'),

            ('T1531', 'Account Access Removal', 'Removing account access.', 'impact'),
            ('T1531', 'Account Access Removal', 'Account disable.', 'impact'),
            ('T1485', 'Data Destruction', 'Destructive attacks.', 'impact'),
            ('T1491', 'Defacement', 'Website defacement.', 'impact'),
            ('T1561', 'Disk Wipe', 'Disk wiping.', 'impact'),
            ('T1499', 'Endpoint Denial of Service', 'DoS attacks.', 'impact'),
            ('T1561', 'Disk Structure Wipe', 'Wiping disk structures.', 'impact'),
            ('T1561.002', 'Disk Wipe: Inhabited Disk Sectors', 'Targeting inhabited sectors.', 'impact'),
            ('T1561.001', 'Disk Wipe: Disk Content Wipe', 'Disk content wipe.', 'impact'),
            ('T1499.001', 'Endpoint Denial of Service: OS Exhaustion Flood', 'OS resource exhaustion.', 'impact'),
            ('T1499.002', 'Endpoint Denial of Service: Service Exhaustion Flood', 'Service exhaustion.', 'impact'),
            ('T1499.003', 'Endpoint Denial of Service: Application Exhaustion Flood', 'App exhaustion.', 'impact'),
            ('T1499.004', 'Endpoint Denial of Service: Application Exhaustion Flood', 'App-level DoS.', 'impact'),
            ('T1561.001', 'Disk Wipe: Disk Content Wipe', 'Disk content wipe (Impact).', 'impact'),
            ('T1491', 'Defacement: Internal Defacement', 'Internal defacement.', 'impact'),
            ('T1491.002', 'Defacement: External Defacement', 'External defacement.', 'impact'),
            ('T1561.002', 'Disk Wipe: Governed Disk Wipe', 'Governed disk wipe.', 'impact'),
            ('T1561', 'Disk Structure Wipe', 'Disk structure wipe (Impact).', 'impact'),
            ('T1499', 'Endpoint Denial of Service', 'Endpoint DoS (Impact).', 'impact'),
            ('T1561.001', 'Disk Wipe: Disk Content Wipe', 'Disk wipe (Impact).', 'impact'),
            ('T1485', 'Data Destruction', 'Data destruction (Impact).', 'impact'),
        ]

        techniques_created = 0
        skipped = 0

        for mitre_id, name, description, tactic_shortname in techniques_data:
            if tactic_shortname not in tactic_map:
                skipped += 1
                continue

            tactic = tactic_map[tactic_shortname]

            obj, is_new = MitreTechnique.objects.update_or_create(
                mitre_id=mitre_id,
                defaults={
                    'name': name,
                    'description': description,
                    'tactic': tactic
                }
            )
            if is_new:
                techniques_created += 1

        self.stdout.write(f'  Techniques: {techniques_created} created/updated ({skipped} skipped)')
```

### api\models.py
```python
import uuid
from django.db import models
from django.contrib.auth.models import AbstractUser

'''
class User(AbstractUser):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    email = models.EmailField(unique=True)
    role = models.CharField(max_length=50, default="student")
    is_verified = models.BooleanField(default=False)

    class Meta:
        db_table = "users"

class RefreshToken(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    user = models.ForeignKey(
        User, on_delete=models.CASCADE, related_name="refresh_tokens"
    )
    token_hash = models.CharField(max_length=255)
    expires_at = models.DateTimeField()
    revoked = models.BooleanField(default=False)

    class Meta:
        db_table = "refresh_tokens"

class KillChainPhase(models.Model):
    id = models.IntegerField(primary_key=True)
    step_number = models.IntegerField(unique=True)
    name = models.CharField(max_length=255, unique=True)
    description = models.TextField(blank=True, null=True)

    class Meta:
        db_table = "kill_chain_phases"

class MitreTactic(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    mitre_id = models.CharField(max_length=100, unique=True)
    name = models.CharField(max_length=255)

    class Meta:
        db_table = "mitre_tactics"

class TacticPhaseMap(models.Model):
    tactic = models.ForeignKey(
        MitreTactic, on_delete=models.CASCADE, related_name="phase_links"
    )
    phase = models.ForeignKey(
        KillChainPhase, on_delete=models.CASCADE, related_name="tactic_links"
    )

    class Meta:
        db_table = "tactic_phase_map"
        unique_together = (("tactic", "phase"),)

class MitreTechnique(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    mitre_id = models.CharField(max_length=100, unique=True)
    name = models.CharField(max_length=255)
    description = models.TextField(blank=True, null=True)
    tactic = models.ForeignKey(
        MitreTactic, on_delete=models.CASCADE, related_name="techniques"
    )

    class Meta:
        db_table = "mitre_techniques"

class Path(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    title = models.CharField(max_length=255)
    slug = models.SlugField(max_length=255, unique=True)
    type = models.CharField(
        max_length=50,
        choices=(("standard", "Standard"), ("campaign", "Campaign")),
    )

    class Meta:
        db_table = "paths"

class Module(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    path = models.ForeignKey(
        Path, on_delete=models.CASCADE, related_name="modules"
    )
    order_index = models.IntegerField()
    title = models.CharField(max_length=255)

    class Meta:
        db_table = "modules"
        unique_together = (("path", "order_index"),)

class Lesson(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    module = models.ForeignKey(
        Module, on_delete=models.CASCADE, related_name="lessons"
    )
    title = models.CharField(max_length=255, blank=True, null=True)
    router_link = models.CharField(max_length=255, blank=True, null=True)

    description = models.TextField(blank=True, null=True)
    key_indicators = models.TextField(blank=True, null=True)

    class Meta:
        db_table = "lessons"

class LessonTechniqueMap(models.Model):
    lesson = models.ForeignKey(
        Lesson, on_delete=models.CASCADE, related_name="technique_links"
    )
    technique = models.ForeignKey(
        MitreTechnique, on_delete=models.CASCADE, related_name="lesson_links"
    )

    class Meta:
        db_table = "lesson_technique_map"
        unique_together = (("lesson", "technique"),)

class Quiz(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    module = models.OneToOneField(
        Module, on_delete=models.CASCADE, related_name="quiz"
    )
    title = models.CharField(max_length=255)

    class Meta:
        db_table = "quizzes"

class QuizQuestion(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    quiz = models.ForeignKey(
        Quiz, on_delete=models.CASCADE, related_name="questions"
    )
    question_text = models.TextField()
    options = models.JSONField()
    correct_answer = models.CharField(max_length=255)

    class Meta:
        db_table = "quiz_questions"

class UserProgress(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    user = models.ForeignKey(
        User, on_delete=models.CASCADE, related_name="progress"
    )
    lesson = models.ForeignKey(
        Lesson, on_delete=models.CASCADE, related_name="user_progress"
    )
    status = models.CharField(
        max_length=50,
        choices=(("completed", "Completed"),),
    )

    class Meta:
        db_table = "user_progress"

class NavBotLog(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    user = models.ForeignKey(
        User,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name="nav_logs",
    )
    command_used = models.CharField(max_length=255, blank=True, null=True)
    query_term = models.CharField(max_length=255, blank=True, null=True)
    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        db_table = "nav_bot_logs"
```

### api\seed.py
```python
from api.models import (
    KillChainPhase,
    MitreTactic,
    Quiz,
    QuizQuestion,
    TacticPhaseMap,
    MitreTechnique,
    Path,
    Module,
    Lesson,
    LessonTechniqueMap
)
import uuid
def run():
        print("ðŸš€ Seeding started")
        phases_by_name = {}

        phase_data = [
            (1, 1, "Reconnaissance", "Adversary researches, identifies, and selects targets using OSINT and scanning."),
            (2, 2, "Weaponization", "Coupling a remote access trojan with an exploit into a deliverable payload like a PDF or Office doc."),
            (3, 3, "Delivery", "Transmitting the weaponized object to the target environment via email, web, or USB."),
            (4, 4, "Exploitation", "Triggering the weapon's code to exploit a vulnerability on the target system."),
            (5, 5, "Installation", "Installing a backdoor, implant, or service to maintain persistence after the initial exploit."),
            (6, 6, "Command and Control", "Establishing a communication channel for the adversary to remotely manipulate the victim system."),
            (7, 7, "Actions on Objectives", "Accomplishing original goals such as data exfiltration, encryption, or lateral movement."),
        ]

        for phase_id, step_number, name, description in phase_data:
            obj, _ = KillChainPhase.objects.update_or_create(
                id=phase_id,
                defaults={
                    "step_number": step_number,
                    "name": name,
                    "description": description,
                },
            )
            phases_by_name[name] = obj

        tactics_by_mitre_id = {}

        tactic_data = [
            ("TA0001", "Initial Access"),
            ("TA0002", "Execution"),
            ("TA0003", "Persistence"),
            ("TA0004", "Privilege Escalation"),
            ("TA0005", "Defense Evasion"),
            ("TA0006", "Credential Access"),
            ("TA0008", "Lateral Movement"),
            ("TA0011", "Command and Control"),
            ("TA0010", "Exfiltration"),
        ]

        for mitre_id, name in tactic_data:
            obj, _ = MitreTactic.objects.update_or_create(
                mitre_id=mitre_id,
                defaults={
                    "name": name,
                },
            )
            tactics_by_mitre_id[mitre_id] = obj

        tactic_phase_data = [
            ("TA0001", 3),
            ("TA0001", 4),
            ("TA0002", 4),
            ("TA0003", 5),
            ("TA0004", 5),
            ("TA0005", 5),
            ("TA0006", 4),  # FIXED
            ("TA0008", 6),  # FIXED
            ("TA0011", 6),
            ("TA0010", 7),
        ]

        for mitre_id, phase_id in tactic_phase_data:
            try:
                tactic = MitreTactic.objects.get(mitre_id=mitre_id)
                phase = KillChainPhase.objects.get(id=phase_id)
            except (MitreTactic.DoesNotExist, KillChainPhase.DoesNotExist):
                continue

            TacticPhaseMap.objects.update_or_create(
                tactic=tactic,
                phase=phase,
                defaults={},
            )

        techniques_by_mitre_id = {}

        technique_data = [
            ("T1190", "Exploit Public-Facing Application","Taking advantage of vulnerable public-facing services like web servers to gain initial access.","TA0001"),
            ("T1566", "Phishing","Sending deceptive emails or messages with malicious links or attachments to trick users into executing malware.","TA0001"),
            ("T1204.002", "User Execution: Malicious File","Tricking users into executing malicious files such as documents or installers delivered via email or download.","TA0001"),
            ("T1059.001", "Command and Scripting Interpreter: PowerShell","Executing malicious code via PowerShell for interactive command execution and payload delivery.","TA0002"),
            ("T1059.003", "Command and Scripting Interpreter: Windows Command Shell","Using cmd.exe to run commands and scripts for system manipulation.","TA0002"),
            ("T1547.001", "Boot or Logon Autostart Execution: Registry Run Keys","Adding malicious executables to Windows Registry Run keys for persistence after reboot.","TA0003"),
            ("T1543.003", "Create or Modify System Process: Windows Service","Installing backdoors as Windows services to maintain persistent access.","TA0003"),
            ("T1053.005", "Scheduled Task/Job: Scheduled Task","Abusing Windows Task Scheduler to execute malicious code persistently or on a schedule.","TA0003"),
            ("T1068", "Exploitation for Privilege Escalation","Exploiting software vulnerabilities to elevate from user to administrator privileges.","TA0004"),
            ("T1548.002", "Bypass User Account Control","Abusing legitimate OS mechanisms to bypass UAC prompts and gain elevated privileges.","TA0004"),
            ("T1562.001", "Impair Defenses: Disable or Modify Tools","Stopping antivirus, EDR, or Windows Defender through service manipulation or DLL replacement.","TA0005"),
            ("T1027", "Obfuscated Files or Information","Encoding payloads with Base64, XOR, or compression to evade signature-based detection.","TA0005"),
            ("T1003.001", "OS Credential Dumping: LSASS Memory","Extracting credentials from LSASS process memory using tools like Mimikatz.","TA0006"),
            ("T1552.001", "Unsecured Credentials: Credentials In Files","Searching local files like configuration files or registry hives for plaintext credentials.","TA0006"),
            ("T1021.001", "Remote Services: Remote Desktop Protocol", "Using RDP to move laterally between compromised Windows systems.","TA0008"),
            ("T1570", "Lateral Tool Transfer","Copying malware or tools to target systems via SMB, WMI, or PsExec.","TA0008"),
            ("T1595", "Active Scanning","Scanning networks and services to identify live hosts, open ports, and exposed services.","TA0008"),
            ("T1090.001", "Proxy: Internal Proxy","Using compromised internal hosts as proxy servers to blend C2 traffic with legitimate traffic.","TA0011"),
            ("T1095", "Non-Application Layer Protocol","Tunneling command and control communications over protocols like DNS, ICMP, or custom protocols.","TA0011"),
            ("T1041", "Exfiltration Over C2 Channel","Using existing command and control infrastructure to stealthily extract sensitive data.","TA0010"),
            ("T1560.001", "Archive Collected Data: Archive via Utility","Compressing stolen data with utilities like ZIP or RAR prior to exfiltration.","TA0010"),
            ("T1078", "Valid Accounts", "Use of stolen, default, or misconfigured accounts to gain access.", "TA0006"),
            ("T1562.002", "Impair Defenses: Modify Security Tools", "Altering or disabling security tooling and controls to avoid detection.", "TA0005"),
            ("T1548.001", "Exploitation for Privilege Escalation: Kernel Exploit", "Exploiting kernel vulnerabilities to gain SYSTEM or higher privileges.", "TA0004"),
            ("T1071.001", "Application Layer Protocol: Web Protocols", "Using HTTP/HTTPS to communicate with command and control infrastructure.", "TA0011"),
            ("T1021.002", "Remote Services: SMB/Windows Admin Shares", "Using SMB or Windows admin shares to move laterally between hosts.", "TA0008"),
            ("T1204.001", "User Execution: Malicious Link", "Convincing a user to click a malicious link leading to payload execution or credential capture.", "TA0002"),
        ]

        for mitre_id, name, description, tactic_mitre_id in technique_data:
            try:
                tactic = MitreTactic.objects.get(mitre_id=tactic_mitre_id)
            except MitreTactic.DoesNotExist:
                continue

            obj, _ = MitreTechnique.objects.update_or_create(
                mitre_id=mitre_id,
                defaults={
                    "name": name,
                    "description": description,
                    "tactic": tactic,
                },
            )
            techniques_by_mitre_id[mitre_id] = obj

        paths_by_slug = {}

        path_data = [
            ("SOC Fundamentals", "soc-fundamentals", "standard"),
            ("Threat Hunting ATT&CK", "threat-hunting-attck", "campaign"),
            ("Advanced Detection Engineering", "advanced-detection-engineering", "standard"),
        ]

        for title, slug, path_type in path_data:
            obj, _ = Path.objects.update_or_create(
                slug=slug,
                defaults={
                    "title": title,
                    "type": path_type,
                },
            )
            paths_by_slug[slug] = obj

        modules_by_path_and_order = {}

        module_data = [
            ("soc-fundamentals", "Introduction to SOC Operations", 1),
            ("soc-fundamentals", "Network Traffic Analysis", 2),
            ("soc-fundamentals", "Windows Event Logs", 3),
            ("soc-fundamentals", "Email Security and Phishing", 4),
            ("soc-fundamentals", "Basic Incident Response", 5),
            ("threat-hunting-attck", "Threat Hunting Principles", 1),
            ("threat-hunting-attck", "Hunting for Persistence", 2),
            ("threat-hunting-attck", "Hunting for Privilege Escalation", 3),
            ("threat-hunting-attck", "Lateral Movement Detection", 4),
            ("threat-hunting-attck", "C2 Beacon Analysis", 5),
            ("advanced-detection-engineering", "Detection Logic Basics", 1),
            ("advanced-detection-engineering", "SIGMA Rule Development", 2),
            ("advanced-detection-engineering", "SIEM Query Optimization", 3),
            ("advanced-detection-engineering", "Adversary Emulation", 4),
            ("advanced-detection-engineering", "Building High-Fidelity Alerts", 5),
        ]

        for path_slug, module_title, order_index in module_data:
            try:
                path = Path.objects.get(slug=path_slug)
            except Path.DoesNotExist:
                continue

            obj, _ = Module.objects.update_or_create(
                path=path,
                order_index=order_index,
                defaults={
                        "title": module_title,

                },
            )
            modules_by_path_and_order[(path_slug, order_index)] = obj

        lessons_by_title = {}

        lesson_data = [
            ("soc-fundamentals", 1, "What is a SOC?", "what-is-soc",
            "Learners understand the role, responsibilities, and daily workflow of Security Operations Center analysts. Core functions include monitoring, triage, investigation, and escalation. SOCs operate 24/7 using SIEM, EDR, and threat intelligence.",
            "high-severity alerts spiking\nunusual login patterns from new geolocations\nSIEM rule violations during off-hours"),

            ("soc-fundamentals", 1, "SOC Tooling Overview", "soc-tooling-overview",
            "Learners identify primary tools used in modern SOC environments. Key platforms include SIEM (Splunk/Elastic), EDR (CrowdStrike), and network monitoring (Zeek). Integration between tools enables correlated alerting and response.",
            "multiple tool alerts correlating to same host\nnew agent installations on endpoints\ntool license usage anomalies"),

            ("soc-fundamentals", 2, "Packet Capture Basics", "packet-capture-basics",
            "Learners interpret basic PCAP files to identify malicious network activity. Focus on protocol anomalies, unusual payloads, and beaconing patterns. PCAP analysis reveals what logs might miss.",
            "suspicious DNS queries to rare domains\nHTTP POSTs to unknown IPs\nnon-standard TLS certificates"),

            ("soc-fundamentals", 2, "Network Scanning Detection", "network-scanning-detection",
            "Learners recognize reconnaissance scanning patterns in network traffic. Port scans, banner grabbing, and vulnerability probing indicate active targeting. Early detection prevents exploitation.",
            "high port scan volume from single source\nSYN floods without completion\nICMP sweeps across subnets"),

            ("soc-fundamentals", 3, "Windows Event ID 4624", "windows-event-4624",
            "Learners analyze successful logon events for compromise indicators. Focus on Logon Type, authentication packages, and source addresses. Correlate with baseline normal activity.",
            "Logon Type 3 from external IPs\nunexpected Kerberos pre-auth failures\nservice account logins to workstations"),

            ("soc-fundamentals", 3, "PowerShell Event Logs", "powershell-event-logs",
            "Learners detect malicious PowerShell execution through event logs. Module 4103/4104 scripts reveal obfuscation, downloads, and command execution. PowerShell is attackers' favorite interpreter.",
            "encoded command parameters\nscript block logging with AMSI bypass attempts\nPowerShell.exe spawned from unusual parents"),

            ("soc-fundamentals", 4, "Phishing Email Indicators", "phishing-email-indicators",
            "Learners identify phishing artifacts in email headers and content. Focus on sender spoofing, malicious links, and attachment anomalies. Phishing remains primary initial access vector.",
            "mismatched DKIM/SPF signatures\nURLs with double encoding\nunexpected macro-enabled Office docs"),

            ("soc-fundamentals", 4, "Malicious Attachment Analysis", "malicious-attachment-analysis",
            "Learners safely analyze Office documents and PDFs for exploits. Embedded macros, JavaScript, and shellcode indicate weaponized payloads. Static/dynamic analysis reveals true intent.",
            "CVE references in metadata\nsuspicious VBA macros\nembedded OLE objects with exploits"),

            ("threat-hunting-attck", 1, "Hypothesis-Driven Hunting", "hypothesis-driven-hunting",
            "Learners build hunting hypotheses based on threat intel and internal changes. Hypotheses link adversary TTPs to detectable log evidence. Proactive hunting finds threats SIEM misses.",
            "sudden increase in admin shares accessed\nunexpected service installations\nanomalous process trees"),

            ("threat-hunting-attck", 1, "Hypothesis Testing Framework", "hypothesis-testing-framework",
            "Learners validate hunting hypotheses through iterative log queries. False positives get refined; true positives trigger investigation. Framework ensures systematic threat discovery.",
            "queries returning consistent anomalies over time\nlow-confidence alerts becoming high-volume\nuncharted log sources lighting up"),

            ("threat-hunting-attck", 2, "Registry Run Key Hunting", "hunting-registry-run-keys",
            "Learners hunt persistence via Registry Run/RunOnce keys. Focus on non-standard paths, unusual filenames, and recent modifications. Run keys enable reboot persistence.",
            "recent modifications to HKLM Software Microsoft Windows CurrentVersion Run\nDLLs in Run key values\nuser-writable Run key locations"),

            ("threat-hunting-attck", 2, "Scheduled Task Persistence", "hunting-scheduled-tasks",
            "Learners detect persistence via Windows Task Scheduler abuse. Malicious tasks run hidden with SYSTEM privileges. Cross-reference task creation events with execution logs.",
            "tasks created outside patch windows\nS4U logon types in task execution\nrecurring tasks with unusual binaries"),

            ("advanced-detection-engineering", 1, "Boolean Logic in SIEM", "boolean-logic-siem",
            "Learners master AND OR NOT operators for precise alert logic. Complex conditions reduce noise while maintaining coverage. Proper logic prevents alert fatigue.",
            "overly broad alerts firing constantly\nmissed detections due to missing exclusions\nlogic errors creating coverage gaps"),

            ("advanced-detection-engineering", 1, "Time Window Correlation", "time-window-correlation",
            "Learners correlate events across time windows for behavioral detection. Sliding windows catch multi-stage attacks. Time-based logic reveals sequences logs hide.",
            "events clustering within 5 minutes\nprecursor activities preceding exploitation\ncoordinated activity across endpoints"),
        ]

        for path_slug, order_index, title, router_link, description, key_indicators in lesson_data:
            try:
                module = Module.objects.get(path__slug=path_slug, order_index=order_index)
            except Module.DoesNotExist:
                continue

            obj, _ = Lesson.objects.update_or_create(
                module=module,
                title=title,
                defaults={
                    "router_link": router_link,
                    "description": description,
                    "key_indicators": key_indicators,
                },
            )
            lessons_by_title[title] = obj

        lesson_technique_data = [
            ("network-scanning-detection", "T1190"),
            ("network-scanning-detection", "T1595"),

            ("powershell-event-logs", "T1059.001"),
            ("powershell-event-logs", "T1027"),
            ("phishing-email-indicators", "T1566"),
            ("malicious-attachment-analysis", "T1566"),
            ("malicious-attachment-analysis", "T1204.002"),
            ("hunting-registry-run-keys", "T1547.001"),
            ("hunting-registry-run-keys", "T1027"),
            ("hunting-scheduled-tasks", "T1053.005"),
            ("hunting-scheduled-tasks", "T1543.003"),
            ("boolean-logic-siem", "T1027"),
            ("time-window-correlation", "T1021.001"),
            ("time-window-correlation", "T1059.003"),
        ]

        for router_link, technique_mitre_id in lesson_technique_data:
            try:
                lesson = Lesson.objects.get(router_link=router_link)
                technique = MitreTechnique.objects.get(mitre_id=technique_mitre_id)
            except (Lesson.DoesNotExist, MitreTechnique.DoesNotExist):
                continue

            LessonTechniqueMap.objects.update_or_create(
                lesson=lesson,
                technique=technique,
                defaults={},
            )

        quizzes_by_module = {}

        quiz_data = [
            ("soc-fundamentals", 1, "SOC Operations & Tooling Quiz"),
            ("soc-fundamentals", 2, "Network Traffic & PCAP Analysis Quiz"),
            ("soc-fundamentals", 3, "Windows Events & PowerShell Logs Quiz"),
            ("soc-fundamentals", 4, "Email Security & Phishing Quiz"),
            ("soc-fundamentals", 5, "Incident Response Basics Quiz"),
            ("threat-hunting-attck", 1, "Hunting Principles & Hypothesis Quiz"),
            ("threat-hunting-attck", 2, "Persistence Mechanisms Quiz"),
            ("threat-hunting-attck", 3, "Privilege Escalation Hunting Quiz"),
            ("threat-hunting-attck", 4, "Lateral Movement Detection Quiz"),
            ("threat-hunting-attck", 5, "C2 & Beaconing Analysis Quiz"),
            ("advanced-detection-engineering", 1, "Detection Logic & Boolean Quiz"),
            ("advanced-detection-engineering", 2, "SIGMA Rules Assessment"),
            ("advanced-detection-engineering", 3, "Query Optimization Quiz"),
            ("advanced-detection-engineering", 4, "Adversary Emulation Quiz"),
            ("advanced-detection-engineering", 5, "High-Fidelity Alerting Quiz"),
        ]

        for path_slug, order_index, title in quiz_data:
            try:
                module = Module.objects.get(path__slug=path_slug, order_index=order_index)
            except Module.DoesNotExist:
                continue

            obj, _ = Quiz.objects.update_or_create(
                module=module,
                defaults={
                    "title": title,
                },
            )
            quizzes_by_module[(path_slug, order_index)] = obj

        quiz_question_data = [
            ("soc-fundamentals", "SOC Operations & Tooling Quiz", "What is the primary function of a Security Operations Center (SOC)?",
            ["To develop new software applications", "To monitor, detect, analyze, and respond to cybersecurity incidents", "To manage IT helpdesk tickets", "To audit financial compliance"],
            "To monitor, detect, analyze, and respond to cybersecurity incidents"),
            ("soc-fundamentals", "SOC Operations & Tooling Quiz", "Which tool is primarily responsible for aggregating logs from various sources for correlation?",
            ["Firewall", "EDR", "SIEM", "Antivirus"],
            "SIEM"),
            ("soc-fundamentals", "SOC Operations & Tooling Quiz", "What distinguishes EDR from traditional Antivirus?",
            ["EDR is free", "EDR focuses on behavioral monitoring and recording endpoint activity", "EDR only scans files on download", "EDR replaces the firewall"],
            "EDR focuses on behavioral monitoring and recording endpoint activity"),
            ("soc-fundamentals", "Network Traffic & PCAP Analysis Quiz", "Which protocol is commonly used by attackers for command and control but often looks like normal web traffic?",
            ["HTTP/HTTPS", "FTP", "Telnet", "SMTP"],
            "HTTP/HTTPS"),
            ("soc-fundamentals", "Network Traffic & PCAP Analysis Quiz", "In a PCAP, what might indicate a port scan?",
            ["A single connection to port 80", "Thousands of SYN packets to different ports from a single IP", "A large file download", "Encrypted SSL traffic"],
            "Thousands of SYN packets to different ports from a single IP"),
            ("soc-fundamentals", "Network Traffic & PCAP Analysis Quiz", "What is 'beaconing' in network traffic analysis?",
            ["A continuous high-bandwidth download", "Regular, heartbeat-like connections to an external IP", "Random connection attempts to internal servers", "Broadcasting ARP requests"],
            "Regular, heartbeat-like connections to an external IP"),
            ("soc-fundamentals", "Windows Events & PowerShell Logs Quiz", "Which Windows Event ID signifies a successful logon?",
            ["4624", "4625", "4688", "4104"],
            "4624"),
            ("soc-fundamentals", "Windows Events & PowerShell Logs Quiz", "Why is PowerShell a frequent target for attackers?",
            ["It is not installed by default", "It allows powerful administration and automation capabilities", "It cannot be logged", "It is only used for web browsing"],
            "It allows powerful administration and automation capabilities"),
            ("soc-fundamentals", "Windows Events & PowerShell Logs Quiz", "What does Event ID 4688 represent?",
            ["A new process has been created", "A user failed to log on", "A file was deleted", "A network share was accessed"],
            "A new process has been created"),
            ("soc-fundamentals", "Email Security & Phishing Quiz", "Which record helps verify that an email actually came from the claimed domain?",
            ["SPF/DKIM", "HTTP", "FTP", "DHCP"],
            "SPF/DKIM"),
            ("soc-fundamentals", "Email Security & Phishing Quiz", "What is a common indicator of a malicious attachment?",
            ["It is a PDF file", "It contains VBA macros that execute on opening", "It is a text file", "It is larger than 10MB"],
            "It contains VBA macros that execute on opening"),
            ("soc-fundamentals", "Email Security & Phishing Quiz", "What is 'typosquatting' in the context of phishing?",
            ["Sending emails with typos", "Registering domains that look visually similar to legitimate ones", "Using poor grammar in email bodies", "Crashing the email server"],
            "Registering domains that look visually similar to legitimate ones"),
            ("soc-fundamentals", "Incident Response Basics Quiz", "What is the first step in the Incident Response lifecycle after preparation?",
            ["Eradication", "Identification (Detection & Analysis)", "Recovery", "Lessons Learned"],
            "Identification (Detection & Analysis)"),
            ("soc-fundamentals", "Incident Response Basics Quiz", "Why is 'containment' critical during an incident?",
            ["To punish the user", "To stop the spread of the attack and prevent further damage", "To delete all logs", "To reboot the server immediately"],
            "To stop the spread of the attack and prevent further damage"),
            ("soc-fundamentals", "Incident Response Basics Quiz", "What is the purpose of the 'Lessons Learned' phase?",
            ["To assign blame", "To improve future response capabilities based on the incident", "To archive data forever", "To fire the security team"],
            "To improve future response capabilities based on the incident"),
            ("threat-hunting-attck", "Hunting Principles & Hypothesis Quiz", "What drives a proactive threat hunt?",
            ["An automated SIEM alert", "A hypothesis based on intelligence or behavioral anomalies", "A user complaint", "A scheduled virus scan"],
            "A hypothesis based on intelligence or behavioral anomalies"),
            ("threat-hunting-attck", "Hunting Principles & Hypothesis Quiz", "What is the goal of hypothesis testing?",
            ["To prove the hypothesis is always true", "To validate if a specific threat behavior exists in the environment", "To generate more logs", "To slow down the network"],
            "To validate if a specific threat behavior exists in the environment"),
            ("threat-hunting-attck", "Hunting Principles & Hypothesis Quiz", "Which is a strong indicator for a hunt hypothesis?",
            ["Normal business hours login", "Sudden use of administrative tools by a non-admin account", "Standard Windows updates", "Daily backup success"],
            "Sudden use of administrative tools by a non-admin account"),
            ("threat-hunting-attck", "Persistence Mechanisms Quiz", "Where do attackers often hide persistence mechanisms in Windows?",
            ["Recycle Bin", "Registry Run Keys (HKLM/HKCU...Run)", "My Documents folder", "Browser History"],
            "Registry Run Keys (HKLM/HKCU...Run)"),
            ("threat-hunting-attck", "Persistence Mechanisms Quiz", "How can Scheduled Tasks be abused for persistence?",
            ["They speed up the system", "They can execute malicious code at specific times or events, even after reboot", "They prevent users from logging in", "They only run standard Microsoft updates"],
            "They can execute malicious code at specific times or events, even after reboot"),
            ("threat-hunting-attck", "Persistence Mechanisms Quiz", "What is a 'service' in the context of persistence?",
            ["A customer support ticket", "A background process that starts automatically on boot", "A network cable", "A firewall rule"],
            "A background process that starts automatically on boot"),
            ("threat-hunting-attck", "Privilege Escalation Hunting Quiz", "What is UAC bypass?",
            ["Skipping the login screen", "Evading the User Account Control prompt to gain elevated privileges silently", "Cracking a password", "Resetting the BIOS"],
            "Evading the User Account Control prompt to gain elevated privileges silently"),
            ("threat-hunting-attck", "Privilege Escalation Hunting Quiz", "Which technique involves exploiting a vulnerability to gain higher access?",
            ["Phishing", "Exploitation for Privilege Escalation", "Port Scanning", "Denial of Service"],
            "Exploitation for Privilege Escalation"),
            ("threat-hunting-attck", "Privilege Escalation Hunting Quiz", "Why might an attacker target LSASS memory?",
            ["To crash the system", "To dump cleartext credentials or hashes", "To increase RAM speed", "To install a printer"],
            "To dump cleartext credentials or hashes"),
            ("threat-hunting-attck", "Lateral Movement Detection Quiz", "What is 'Pass-the-Hash'?",
            ["Sending a password via email", "Authenticating using a hashed password without knowing the cleartext", "Resetting a user's password", "Encrypting the hard drive"],
            "Authenticating using a hashed password without knowing the cleartext"),
            ("threat-hunting-attck", "Lateral Movement Detection Quiz", "Which protocol is frequently used for lateral movement in Windows environments?",
            ["SMB/RPC", "HTTP", "FTP", "SMTP"],
            "SMB/RPC"),
            ("threat-hunting-attck", "Lateral Movement Detection Quiz", "What might indicate lateral movement via RDP?",
            ["RDP connections from external IPs", "RDP connections between workstations", "RDP connections to a domain controller from a workstation", "All of the above"],
            "All of the above"),
            ("threat-hunting-attck", "C2 & Beaconing Analysis Quiz", "What characterizes a 'jitter' in C2 beaconing?",
            ["Consistent 1-second intervals", "Randomized timing between callbacks to evade detection", "A fast network connection", "Packet loss"],
            "Randomized timing between callbacks to evade detection"),
            ("threat-hunting-attck", "C2 & Beaconing Analysis Quiz", "Why do attackers use Domain Generation Algorithms (DGA)?",
            ["To save money on domains", "To dynamically generate many domain names to evade blacklisting", "To improve website SEO", "To encrypt traffic"],
            "To dynamically generate many domain names to evade blacklisting"),
            ("threat-hunting-attck", "C2 & Beaconing Analysis Quiz", "What is 'DNS Tunneling'?",
            ["Using DNS queries to encode and transport data", "Blocking DNS requests", "Accelerating DNS resolution", "A VPN protocol"],
            "Using DNS queries to encode and transport data"),
            ("advanced-detection-engineering", "Detection Logic & Boolean Quiz", "What does the boolean operator 'AND' achieve in a detection rule?",
            ["Broadens the search results", "Narrows the criteria so all conditions must be met", "Excludes specific results", "Prioritizes the first term"],
            "Narrows the criteria so all conditions must be met"),
            ("advanced-detection-engineering", "Detection Logic & Boolean Quiz", "Why is 'NOT' useful in query logic?",
            ["To include everything", "To filter out known good behavior (whitelisting)", "To make the query faster", "To delete logs"],
            "To filter out known good behavior (whtelisting)"),
            ("advanced-detection-engineering", "Detection Logic & Boolean Quiz", "What is a false positive?",
            ["A missed attack", "A benign event incorrectly flagged as malicious", "A malicious event correctly identified", "A system crash"],
            "A benign event incorrectly flagged as malicious"),
            ("advanced-detection-engineering", "SIGMA Rules Assessment", "What is the primary purpose of SIGMA rules?",
            ["To block firewalls", "To provide a generic, vendor-agnostic format for describing detection signatures", "To encrypt logs", "To manage user passwords"],
            "To provide a generic, vendor-agnostic format for describing detection signatures"),
            ("advanced-detection-engineering", "SIGMA Rules Assessment", "Which field in a SIGMA rule describes the log source?",
            ["detection", "logsource", "condition", "title"],
            "logsource"),
            ("advanced-detection-engineering", "SIGMA Rules Assessment", "How are SIGMA rules typically used?",
            ["They are run directly on the endpoint", "They are converted into SIEM-specific queries (Splunk, ELK, etc.)", "They replace antivirus", "They operate only on network traffic"],
            "They are converted into SIEM-specific queries (Splunk, ELK, etc.)"),
            ("advanced-detection-engineering", "Query Optimization Quiz", "Why should you avoid leading wildcards (e.g., *malware) in queries?",
            ["It looks ugly", "It is computationally expensive and slow", "It returns too few results", "It crashes the internet"],
            "It is computationally expensive and slow"),
            ("advanced-detection-engineering", "Query Optimization Quiz", "What is the benefit of filtering by 'sourcetype' or 'index' first?",
            ["It limits the dataset early, improving search speed", "It makes the query longer", "It hides data", "It is required by law"],
            "It limits the dataset early, improving search speed"),
            ("advanced-detection-engineering", "Query Optimization Quiz", "When should you use 'stats' or aggregation commands?",
            ["Always", "To summarize data and identify patterns or counts", "Never", "Only for graphical charts"],
            "To summarize data and identify patterns or counts"),
            ("advanced-detection-engineering", "Adversary Emulation Quiz", "What is the goal of adversary emulation?",
            ["To hack competitors", "To test defenses by mimicking known adversary TTPs", "To train AI models", "To check internet speed"],
            "To test defenses by mimicking known adversary TTPs"),
            ("advanced-detection-engineering", "Adversary Emulation Quiz", "Which tool is commonly used for atomic test execution?",
            ["Wireshark", "Atomic Red Team", "Notepad++", "Calculator"],
            "Atomic Red Team"),
            ("advanced-detection-engineering", "Adversary Emulation Quiz", "How does emulation differ from vulnerability scanning?",
            ["It focuses on behavior and detection validation, not just software flaws", "It is cheaper", "It is automated only", "It runs on Linux only"],
            "It focuses on behavior and detection validation, not just software flaws"),
            ("advanced-detection-engineering", "High-Fidelity Alerting Quiz", "What characterizes a high-fidelity alert?",
            ["Low confidence, high volume", "High confidence, low false positive rate, actionable", "Random generation", "Informational only"],
            "High confidence, low false positive rate, actionable"),
            ("advanced-detection-engineering", "High-Fidelity Alerting Quiz", "What is 'alert fatigue'?",
            ["Being tired from work", "Desensitization to alerts due to high volume of false positives", "A feature of SIEMs", "A type of malware"],
            "Desensitization to alerts due to high volume of false positives"),
            ("advanced-detection-engineering", "High-Fidelity Alerting Quiz", "How can you improve alert fidelity?",
            ["Remove all logic", "Tune logic to exclude known benign behavior and add context", "Alert on every event", "Turn off the SIEM"],
            "Tune logic to exclude known benign behavior and add context"),
        ]

        for path_slug, quiz_title, question_text, options, correct_answer in quiz_question_data:
            try:
                quiz = Quiz.objects.get(
                    module__path__slug=path_slug,
                    title=quiz_title,
                )
            except Quiz.DoesNotExist:
                continue

            QuizQuestion.objects.update_or_create(
                quiz=quiz,
                question_text=question_text,
                defaults={
                    "options": options,
                    "correct_answer": correct_answer,
                },
            )

        print("âœ… Seeding completed")
```

### api\serializers.py
```python
from django.contrib.auth import get_user_model
from rest_framework import serializers
from .models import (
    Path, Module, Lesson,
    KillChainPhase, MitreTactic, MitreTechnique,
    LessonTechniqueMap, TacticPhaseMap,
    UserProgress, NavBotLog
)
User = get_user_model()

class UserSerializer(serializers.ModelSerializer):
    class Meta:
        model = User
        fields = ["id", "username", "password", "email", "role", "is_verified"]
        extra_kwargs = {
            "password": {"write_only": True},
            "email": {"required": True},
        }

    def create(self, validated_data):
        password = validated_data.pop("password")
        user = User(**validated_data)
        user.set_password(password)
        user.save()
        return user

class KillChainPhaseSerializer(serializers.ModelSerializer):
    class Meta:
        model = KillChainPhase
        fields = ["id", "step_number", "name", "description"]

class MitreTacticSerializer(serializers.ModelSerializer):
    class Meta:
        model = MitreTactic
        fields = ["id", "mitre_id", "name"]

class MitreTechniqueSerializer(serializers.ModelSerializer):
    tactic_name = serializers.CharField(source='tactic.name', read_only=True)

    class Meta:
        model = MitreTechnique
        fields = ["id", "mitre_id", "name", "description", "tactic", "tactic_name"]

class LessonTechniqueMapSerializer(serializers.ModelSerializer):
    technique = MitreTechniqueSerializer(read_only=True)

    class Meta:
        model = LessonTechniqueMap
        fields = ["id", "lesson", "technique"]

class LessonSerializer(serializers.ModelSerializer):
    techniques = serializers.SerializerMethodField()

    class Meta:
        model = Lesson
        fields = ["id", "module", "title", "router_link", "description", "key_indicators", "techniques"]

    def get_techniques(self, obj):
        technique_links = obj.technique_links.all()
        return MitreTechniqueSerializer([link.technique for link in technique_links], many=True).data

class ModuleSerializer(serializers.ModelSerializer):
    lessons = LessonSerializer(many=True, read_only=True)

    class Meta:
        model = Module
        fields = ["id", "path", "order_index", "title", "lessons"]

class PathSerializer(serializers.ModelSerializer):
    modules = ModuleSerializer(many=True, read_only=True)

    class Meta:
        model = Path
        fields = ["id", "title", "slug", "type", "modules"]

class TacticPhaseMapSerializer(serializers.ModelSerializer):
    class Meta:
        model = TacticPhaseMap
        fields = ["id", "tactic", "phase"]

class UserProgressSerializer(serializers.ModelSerializer):
    class Meta:
        model = UserProgress
        fields = ["id", "user", "lesson", "status"]

class NavBotLogSerializer(serializers.ModelSerializer):
    class Meta:
        model = NavBotLog
        fields = ["id", "user", "command_used", "query_term", "created_at"]
```

### api\urls.py
```python
from django.urls import path
from . import views

'''
urlpatterns = [

    path("paths/", views.PathListCreate.as_view(), name="path-list"),
    path("paths/<uuid:pk>/", views.PathDetail.as_view(), name="path-detail"),

    path("modules/", views.ModuleListCreate.as_view(), name="module-list"),
    path("modules/<uuid:pk>/", views.ModuleDetail.as_view(), name="module-detail"),

    path("lessons/", views.LessonListCreate.as_view(), name="lesson-list"),
    path("lessons/<uuid:pk>/", views.LessonDetail.as_view(), name="lesson-detail"),
    path("lessons/<uuid:pk>/complete/", views.LessonCompleteView.as_view(), name="lesson-complete"),

    path(
        "kill-chain-phases/",
        views.KillChainPhaseList.as_view(),
        name="kill-chain-phase-list",
    ),
    path(
        "mitre-tactics/",
        views.MitreTacticList.as_view(),
        name="mitre-tactic-list",
    ),
    path(
        "mitre-techniques/",
        views.MitreTechniqueList.as_view(),
        name="mitre-technique-list",
    ),
    path(
        "frameworks/tactics/<uuid:tactic_id>/techniques/",
        views.TechniquesByTacticList.as_view(),
        name="techniques-by-tactic",
    ),

    path(
        "lesson-techniques/",
        views.LessonTechniqueMapListCreate.as_view(),
        name="lesson-technique-map-list",
    ),
    path(
        "tactic-phases/",
        views.TacticPhaseMapListCreate.as_view(),
        name="tactic-phase-map-list",
    ),

    path(
        "user-progress/",
        views.UserProgressListCreate.as_view(),
        name="user-progress-list",
    ),
    path(
        "nav-logs/",
        views.NavBotLogListCreate.as_view(),
        name="nav-bot-log-list",
    ),
    path("navigator/command", views.NavigatorCommandView.as_view(), name="navigator-command"),
    path(
        "dashboard/",
        views.DashboardStatsView.as_view(),
        name="dashboard-stats",
    ),
    path(
        "frameworks/tactics/",
        views.FrameworkTacticsView.as_view(),
        name="framework-tactics",
    ),
]
```

### api\views.py
```python
from django.contrib.auth import get_user_model
from rest_framework import generics
from rest_framework.response import Response
from rest_framework.permissions import AllowAny, IsAuthenticated

from .serializers import (
    UserSerializer, PathSerializer, ModuleSerializer, LessonSerializer,
    KillChainPhaseSerializer, MitreTacticSerializer, MitreTechniqueSerializer,
    LessonTechniqueMapSerializer, TacticPhaseMapSerializer,
    UserProgressSerializer, NavBotLogSerializer
)
from .models import (
    Path, Module, Lesson,
    KillChainPhase, MitreTactic, MitreTechnique,
    LessonTechniqueMap, TacticPhaseMap,
    UserProgress, NavBotLog
)

User = get_user_model()

class CreateUserView(generics.CreateAPIView):
    queryset = User.objects.all()
    serializer_class = UserSerializer
    permission_classes = [AllowAny]

class PathListCreate(generics.ListCreateAPIView):
    queryset = Path.objects.all()
    serializer_class = PathSerializer
    permission_classes = [IsAuthenticated]

class PathDetail(generics.RetrieveUpdateDestroyAPIView):
    queryset = Path.objects.all()
    serializer_class = PathSerializer
    permission_classes = [IsAuthenticated]

class ModuleListCreate(generics.ListCreateAPIView):
    queryset = Module.objects.all()
    serializer_class = ModuleSerializer
    permission_classes = [IsAuthenticated]

class ModuleDetail(generics.RetrieveUpdateDestroyAPIView):
    queryset = Module.objects.all()
    serializer_class = ModuleSerializer
    permission_classes = [IsAuthenticated]

class LessonListCreate(generics.ListCreateAPIView):
    queryset = Lesson.objects.all()
    serializer_class = LessonSerializer
    permission_classes = [IsAuthenticated]

class LessonDetail(generics.RetrieveUpdateDestroyAPIView):
    queryset = Lesson.objects.all()
    serializer_class = LessonSerializer
    permission_classes = [IsAuthenticated]

class KillChainPhaseList(generics.ListAPIView):
    queryset = KillChainPhase.objects.all()
    serializer_class = KillChainPhaseSerializer
    permission_classes = [IsAuthenticated]

class MitreTacticList(generics.ListAPIView):
    queryset = MitreTactic.objects.all()
    serializer_class = MitreTacticSerializer
    permission_classes = [IsAuthenticated]

class MitreTechniqueList(generics.ListAPIView):
    queryset = MitreTechnique.objects.all()
    serializer_class = MitreTechniqueSerializer
    permission_classes = [IsAuthenticated]

class LessonTechniqueMapListCreate(generics.ListCreateAPIView):
    queryset = LessonTechniqueMap.objects.all()
    serializer_class = LessonTechniqueMapSerializer
    permission_classes = [IsAuthenticated]

class TacticPhaseMapListCreate(generics.ListCreateAPIView):
    queryset = TacticPhaseMap.objects.all()
    serializer_class = TacticPhaseMapSerializer
    permission_classes = [IsAuthenticated]

class UserProgressListCreate(generics.ListCreateAPIView):
    queryset = UserProgress.objects.all()
    serializer_class = UserProgressSerializer
    permission_classes = [IsAuthenticated]

class NavBotLogListCreate(generics.ListCreateAPIView):
    queryset = NavBotLog.objects.all()
    serializer_class = NavBotLogSerializer
    permission_classes = [IsAuthenticated]

'''
class DashboardStatsView(generics.RetrieveAPIView):
    permission_classes = [IsAuthenticated]

    def get(self, request, *args, **kwargs):
        user = request.user
        mastered_techniques = UserProgress.objects.filter(user=user, status='mastered').count()
        labs_completed = UserProgress.objects.filter(user=user, status='completed').count()

        xp = (mastered_techniques * 50) + (labs_completed * 100)

        level = 1 + (xp // 500)

        data = {
            "xp": xp,
            "level": level,
            "techniques_mastered": mastered_techniques,
            "labs_completed": labs_completed,
            "streak": 0  # Placeholder
        }
        return Response(data)

class FrameworkTacticsView(generics.ListAPIView):
    queryset = MitreTactic.objects.all()
    serializer_class = MitreTacticSerializer
    permission_classes = [IsAuthenticated]

    def list(self, request, *args, **kwargs):
        queryset = self.get_queryset()
        serializer = self.get_serializer(queryset, many=True)
        data = []
        for tactic in queryset:
            data.append({
                "id": tactic.id,
                "mitre_id": tactic.mitre_id,
                "name": tactic.name,
                "description": f"Tactics for {tactic.name}", # Placeholder description if not in model
                "technique_count": MitreTechnique.objects.filter(tactic=tactic).count()
            })
        return Response(data)

class TechniquesByTacticList(generics.ListAPIView):
    serializer_class = MitreTechniqueSerializer
    permission_classes = [IsAuthenticated]

    def get_queryset(self):
        tactic_id = self.kwargs['tactic_id']
        return MitreTechnique.objects.filter(tactic__id=tactic_id)

from rest_framework.views import APIView
from rest_framework import status
from django.shortcuts import get_object_or_404

class NavigatorCommandView(APIView):
    """Simple navigator command endpoint used by the frontend Navigator component.
    permission_classes = [IsAuthenticated]

    def post(self, request, *args, **kwargs):
        data = request.data or {}
        cmd_raw = data.get("input", "")
        cmd = (cmd_raw or "").strip()
        context = data.get("context", {})

        if cmd.lower().startswith("navigate "):
            url = cmd.split(" ", 1)[1]
            return Response({"type": "action", "payload": {"action": "navigate", "url": url}})

        if cmd.lower().startswith("technique ") or cmd.lower().startswith("show technique "):
            term = cmd.split(" ", 1)[1]
            try:
                tech = MitreTechnique.objects.filter(mitre_id__iexact=term).first()
                if not tech:
                    tech = MitreTechnique.objects.filter(name__icontains=term).first()
                if tech:
                    payload = {
                        "id": str(tech.id),
                        "mitre_id": tech.mitre_id,
                        "name": tech.name,
                        "description": tech.description,
                    }
                    return Response({"type": "technique_detail", "payload": payload})
            except Exception:
                pass
            return Response({"type": "options", "payload": {"message": "Technique not found", "options": []}})

        if cmd.lower() == "stats":
            total = MitreTechnique.objects.count()
            mastered = 0
            if request.user and request.user.is_authenticated:
                mastered = request.user.userprogress_set.filter(status="mastered").count()
            pct = int((mastered / total) * 100) if total else 0
            payload = {
                "percentage": pct,
                "techniques_mastered": mastered,
                "techniques_total": total,
                "current_path": context.get("current_page", ""),
            }
            return Response({"type": "stats", "payload": payload})

        return Response({"type": "options", "payload": {"message": f"Unrecognized command: {cmd_raw}", "options": []}})

class LessonCompleteView(APIView):
    permission_classes = [IsAuthenticated]

    def post(self, request, pk, *args, **kwargs):
        lesson = get_object_or_404(Lesson, pk=pk)
        progress, created = UserProgress.objects.get_or_create(
            user=request.user,
            lesson=lesson,
            defaults={'status': 'completed'}
        )
        if not created and progress.status != 'completed':
            progress.status = 'completed'
            progress.save()

        return Response({"status": "success", "message": "Lesson marked as completed."}, status=status.HTTP_200_OK)
```

### backend\requirement.txt
```
asgiref
Django
django-cors-headers
djangorestframework
djangorestframework-simplejwt
PyJWT
pytz
sqlparse
psycopg2-binary
python-dotenv
django-environ
taxii2-client
stix2
```

### backend\settings.py
```python
from pathlib import Path
from datetime import timedelta
from dotenv import load_dotenv
import os

load_dotenv()
BASE_DIR = Path(__file__).resolve().parent.parent

SECRET_KEY = 'os.getenv("SECRET_KEY")'

DEBUG = True

ALLOWED_HOSTS = ["*"]

REST_FRAMEWORK = {
    "DEFAULT_AUTHENTICATION_CLASSES": (
        "rest_framework_simplejwt.authentication.JWTAuthentication",
    ),
    "DEFAULT_PERMISSION_CLASSES": [
        "rest_framework.permissions.IsAuthenticated",
    ],
}

SIMPLE_JWT = {
    "ACCESS_TOKEN_LIFETIME": timedelta(minutes=30),
    "REFRESH_TOKEN_LIFETIME": timedelta(days=1),
}

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'api',
    'rest_framework',
    'corsheaders'
]
AUTH_USER_MODEL = "api.User"

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
    'corsheaders.middleware.CorsMiddleware',
]

ROOT_URLCONF = 'backend.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'backend.wsgi.application'

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': os.getenv('DB_NAME'),
        'USER': os.getenv('DB_USER'),
        'PASSWORD': os.getenv('DB_PASSWORD'),
        'HOST': os.getenv('DB_HOST'),
        'PORT': os.getenv('DB_PORT'),
    }
}

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]

LANGUAGE_CODE = 'en-us'

TIME_ZONE = 'UTC'

USE_I18N = True

USE_TZ = True

STATIC_URL = 'static/'

CORS_ALLOW_ALL_ORIGINS = True
CORS_ALLOW_CREDENTIALS = True

CSRF_TRUSTED_ORIGINS = [
    "http://localhost:5173",
    "http://127.0.0.1:5173",
]

CORS_ALLOWED_ORIGINS = [
    "http://localhost:5173",
    "http://127.0.0.1:5173",
]
```

### backend\urls.py
```python
from django.contrib import admin
from django.urls import path,include
from api.views import CreateUserView
from rest_framework_simplejwt.views import TokenObtainPairView,TokenRefreshView
urlpatterns = [
    path('admin/', admin.site.urls),
    path('api/user/register/', CreateUserView.as_view(), name='register'),
    path('api/token/', TokenObtainPairView.as_view(), name='get_token'),
    path('api/token/refresh/', TokenRefreshView.as_view(), name='refresh'),
    path('api/auth/', include('rest_framework.urls')),# browsable API login
   path('api/', include('api.urls'))
]
```

### check_relationships.py
```python
import os
import django

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'backend.settings')
django.setup()

from api.models import (
    Path, Module, Lesson, 
    MitreTactic, MitreTechnique, KillChainPhase,
    LessonTechniqueMap, TacticPhaseMap
)

print("\n" + "="*70)
print("DATABASE RELATIONSHIP CHECK")
print("="*70)

print("\n1. PATHS")
paths = Path.objects.all()
print(f"   Total: {paths.count()}")
for path in paths:
    print(f"   - {path.title} ({path.slug})")

print("\n2. MODULES")
modules = Module.objects.all()
print(f"   Total: {modules.count()}")
for module in modules[:5]:
    print(f"   - {module.title} (Path: {module.path.title if module.path else 'N/A'})")

print("\n3. LESSONS")
lessons = Lesson.objects.all()
print(f"   Total: {lessons.count()}")
for lesson in lessons[:5]:
    print(f"   - {lesson.title} (Module: {lesson.module.title if lesson.module else 'N/A'})")

print("\n4. MITRE TACTICS")
tactics = MitreTactic.objects.all()
print(f"   Total: {tactics.count()}")
for tactic in tactics[:5]:
    print(f"   - {tactic.name} ({tactic.mitre_id})")

print("\n5. MITRE TECHNIQUES")
techniques = MitreTechnique.objects.all()
print(f"   Total: {techniques.count()}")
for technique in techniques[:5]:
    print(f"   - {technique.name} ({technique.mitre_id}) -> Tactic: {technique.tactic.name}")

print("\n6. LESSON-TECHNIQUE MAPPINGS")
lesson_technique_maps = LessonTechniqueMap.objects.all()
print(f"   Total: {lesson_technique_maps.count()}")
for ltm in lesson_technique_maps[:5]:
    print(f"   - {ltm.lesson.title} -> {ltm.technique.name}")

print("\n7. TACTIC-PHASE MAPPINGS")
tactic_phase_maps = TacticPhaseMap.objects.all()
print(f"   Total: {tactic_phase_maps.count()}")
for tpm in tactic_phase_maps[:5]:
    print(f"   - {tpm.tactic.name} -> {tpm.phase.name}")

print("\n8. DETAILED LESSON ANALYSIS")
print("   Sample lessons with their connected techniques:")
lessons_with_techniques = Lesson.objects.filter(technique_links__isnull=False).distinct()
print(f"   Lessons with techniques: {lessons_with_techniques.count()}")
for lesson in lessons_with_techniques[:3]:
    techniques = lesson.technique_links.all()
    print(f"\n   Lesson: {lesson.title}")
    print(f"   Connected techniques: {techniques.count()}")
    for tech in techniques:
        print(f"     - {tech.technique.name} ({tech.technique.mitre_id})")

print("\n" + "="*70)
```

### check_users.py
```python
import os
import django

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'backend.settings')
django.setup()

from api.models import User

users = User.objects.all()
print("\n=== CURRENT USERS IN DATABASE ===\n")
if users.exists():
    for user in users:
        print(f"ID: {user.id}")
        print(f"Username: {user.username}")
        print(f"Email: {user.email}")
        print(f"Is Staff: {user.is_staff}")
        print(f"Is Superuser: {user.is_superuser}")
        print(f"Date Joined: {user.date_joined}")
        print("-" * 40)
else:
    print("No users found in the database.")
```

### codebase_exporter.py
```python
"""

import os
import re
from pathlib import Path
from datetime import datetime
from typing import Optional, Set, List, Dict
import hashlib

DJANGO_BOILERPLATE_FILES = {
    'manage.py', 'wsgi.py', 'asgi.py', 'apps.py',
    'conftest.py', 'pytest.ini', 'setup.cfg',
}

DJANGO_BOILERPLATE_DIRS = {
    'migrations', '__pycache__', '.git', '.venv', 'venv',
    'env', 'staticfiles', 'static/admin', 'media',
    '.pytest_cache', '.mypy_cache', 'htmlcov', '.tox',
    'site-packages', 'egg-info', '.eggs',
}

REACT_BOILERPLATE_FILES = {
    'reportWebVitals.js', 'reportWebVitals.ts',
    'setupTests.js', 'setupTests.ts',
    'serviceWorker.js', 'service-worker.js',
    'react-app-env.d.ts', 'logo.svg',
    'App.test.js', 'App.test.tsx',
    'favicon.ico', 'manifest.json', 'robots.txt',
}

REACT_BOILERPLATE_DIRS = {
    'node_modules', 'build', 'dist', 'coverage',
    '.next', '.nuxt', 'out', '.cache',
}

ALWAYS_EXCLUDE_FILES = {
    '.DS_Store', 'Thumbs.db', '.gitignore', '.gitattributes',
    'package-lock.json', 'yarn.lock', 'pnpm-lock.yaml',
    'poetry.lock', 'Pipfile.lock', 'requirements.txt',
    '.env', '.env.local', '.env.development', '.env.production',
    'docker-compose.yml', 'Dockerfile', '.dockerignore',
    '.prettierrc', '.eslintrc', '.eslintrc.js', '.eslintrc.json',
    'tsconfig.json', 'jsconfig.json', 'babel.config.js',
    '.babelrc', 'webpack.config.js', 'vite.config.js',
    'tailwind.config.js', 'postcss.config.js',
    'jest.config.js', 'jest.config.ts',
}

ALWAYS_EXCLUDE_EXTENSIONS = {
    '.pyc', '.pyo', '.exe', '.dll', '.so', '.dylib',
    '.png', '.jpg', '.jpeg', '.gif', '.ico', '.svg', '.webp',
    '.woff', '.woff2', '.ttf', '.eot', '.otf',
    '.mp3', '.mp4', '.wav', '.avi', '.mov',
    '.pdf', '.doc', '.docx', '.xls', '.xlsx',
    '.zip', '.tar', '.gz', '.rar', '.7z',
    '.sqlite3', '.db', '.log', '.map',
}

BOILERPLATE_PATTERNS = [
    r'^# Generated by Django',
    r'^// This file was auto-generated',
    r'from django\.contrib import admin\s*\n\s*# Register your models here\.\s*$',
    r'^from django\.test import TestCase\s*\n\s*# Create your tests here\.\s*$',
    r'^from django\.shortcuts import render\s*\n\s*# Create your views here\.\s*$',
    r'^from django\.db import models\s*\n\s*# Create your models here\.\s*$',
    r'ReactDOM\.(render|createRoot).*<App\s*/?>.*',
]

class CodebaseExtractor:
    """Efficient codebase extractor for Django + React projects."""

    def __init__(
        self,
        root_dir: str = ".",
        output_file: str = "codebase_contents.txt",
        max_file_size: int = 100 * 1024,  # 100KB default (reduced)
        include_tests: bool = False,
        include_configs: bool = False,
        compact_mode: bool = True,
    ):
        self.root_path = Path(root_dir).resolve()
        self.output_file = output_file
        self.max_file_size = max_file_size
        self.include_tests = include_tests
        self.include_configs = include_configs
        self.compact_mode = compact_mode

        self.stats = {
            'included': 0,
            'skipped_boilerplate': 0,
            'skipped_size': 0,
            'skipped_binary': 0,
            'skipped_empty': 0,
        }
        self.skipped_files: List[str] = []

        self.exclude_dirs = (
            DJANGO_BOILERPLATE_DIRS | 
            REACT_BOILERPLATE_DIRS | 
            {'.git', '.idea', '.vscode'}
        )
        self.exclude_files = (
            DJANGO_BOILERPLATE_FILES | 
            REACT_BOILERPLATE_FILES | 
            ALWAYS_EXCLUDE_FILES |
            {output_file}
        )

    def extract(self) -> None:
        """Main extraction method."""
        with open(self.output_file, 'w', encoding='utf-8') as out:
            self._write_header(out)
            self._write_structure(out)
            self._write_contents(out)
            self._write_summary(out)

        self._print_stats()

    def _write_header(self, out) -> None:
        """Write minimal header."""
        out.write(f"# CODEBASE: {self.root_path.name}\n")
        out.write(f"# Generated: {datetime.now().strftime('%Y-%m-%d %H:%M')}\n")
        out.write("=" * 60 + "\n\n")

    def _write_structure(self, out) -> None:
        """Write compact directory structure."""
        out.write("## STRUCTURE\n")
        out.write("-" * 30 + "\n")

        for line in self._generate_tree():
            out.write(line + "\n")
        out.write("\n")

    def _generate_tree(self) -> List[str]:
        """Generate compact tree structure."""
        lines = [f"{self.root_path.name}/"]
        self._add_tree_level(self.root_path, "", lines)
        return lines

    def _add_tree_level(self, path: Path, prefix: str, lines: List[str]) -> None:
        """Recursively add tree levels."""
        try:
            entries = sorted(
                [e for e in path.iterdir() if not self._should_exclude_from_tree(e)],
                key=lambda x: (x.is_file(), x.name.lower())
            )
        except PermissionError:
            return

        for i, entry in enumerate(entries):
            is_last = i == len(entries) - 1
            connector = "â””â”€ " if is_last else "â”œâ”€ "

            if entry.is_dir():
                lines.append(f"{prefix}{connector}{entry.name}/")
                extension = "   " if is_last else "â”‚  "
                self._add_tree_level(entry, prefix + extension, lines)
            else:
                # Mark important files
                marker = self._get_file_marker(entry)
                lines.append(f"{prefix}{connector}{entry.name}{marker}")

    def _get_file_marker(self, path: Path) -> str:
        """Get marker for file importance."""
        name = path.name.lower()

        if name in ('models.py', 'views.py', 'urls.py', 'serializers.py', 'forms.py'):
            return " *"
        if name.endswith(('.jsx', '.tsx')) and 'test' not in name.lower():
            return " *"
        if 'settings' in name or name == 'urls.py':
            return " !"
        return ""

    def _should_exclude_from_tree(self, path: Path) -> bool:
        """Check if path should be excluded from tree."""
        if path.is_dir():
            return path.name in self.exclude_dirs
        return path.suffix.lower() in ALWAYS_EXCLUDE_EXTENSIONS

    def _write_contents(self, out) -> None:
        """Write file contents."""
        out.write("=" * 60 + "\n")
        out.write("## FILES\n")
        out.write("=" * 60 + "\n")

        for file_path in self._get_project_files():
            self._process_file(file_path, out)

    def _get_project_files(self):
        """Get all relevant project files."""
        for item in sorted(self.root_path.rglob("*")):
            if item.is_file() and self._should_include(item):
                yield item

    def _should_include(self, path: Path) -> bool:
        """Determine if file should be included."""
        name = path.name
        suffix = path.suffix.lower()
        rel_path = str(path.relative_to(self.root_path))

        if suffix in ALWAYS_EXCLUDE_EXTENSIONS:
            return False

        for parent in path.parents:
            if parent.name in self.exclude_dirs:
                return False

        if name in self.exclude_files:
            self.skipped_files.append(f"{rel_path} (boilerplate)")
            self.stats['skipped_boilerplate'] += 1
            return False

        if not self.include_tests:
            if 'test' in name.lower() or '/tests/' in rel_path or '\\tests\\' in rel_path:
                self.skipped_files.append(f"{rel_path} (test file)")
                return False

        if name == '__init__.py':
            try:
                content = path.read_text(encoding='utf-8', errors='ignore')
                if len(content.strip()) < 50:  # Nearly empty
                    return False
            except:
                return False

        return True

    def _process_file(self, file_path: Path, out) -> None:
        """Process and write a single file."""
        rel_path = file_path.relative_to(self.root_path)

        try:
            file_size = file_path.stat().st_size

            if file_size > self.max_file_size:
                self.skipped_files.append(f"{rel_path} (size: {file_size//1024}KB)")
                self.stats['skipped_size'] += 1
                return

            if file_size == 0:
                self.stats['skipped_empty'] += 1
                return

            content = self._read_file(file_path)
            if content is None:
                self.stats['skipped_binary'] += 1
                self.skipped_files.append(f"{rel_path} (binary)")
                return

            if self._is_boilerplate_content(content, file_path):
                self.skipped_files.append(f"{rel_path} (boilerplate content)")
                self.stats['skipped_boilerplate'] += 1
                return

            processed_content = self._process_content(content, file_path)

            self._write_file_section(out, rel_path, processed_content, file_size)
            self.stats['included'] += 1

        except Exception as e:
            self.skipped_files.append(f"{rel_path} (error: {str(e)[:30]})")

    def _read_file(self, file_path: Path) -> Optional[str]:
        """Read file with encoding detection."""
        try:
            with open(file_path, 'rb') as f:
                chunk = f.read(1024)
                if b'\x00' in chunk:
                    return None
        except:
            return None

        for encoding in ['utf-8', 'utf-8-sig', 'latin-1']:
            try:
                return file_path.read_text(encoding=encoding)
            except UnicodeDecodeError:
                continue
            except Exception:
                return None
        return None

    def _is_boilerplate_content(self, content: str, file_path: Path) -> bool:
        """Check if content is boilerplate."""
        content_stripped = content.strip()

        if len(content_stripped) < 100:
            lines = [l.strip() for l in content_stripped.split('\n') if l.strip()]
            if all(l.startswith(('import ', 'from ', '#', '//', '/*', '*')) for l in lines):
                return True

        for pattern in BOILERPLATE_PATTERNS:
            if re.search(pattern, content_stripped, re.MULTILINE | re.DOTALL):
                return True

        if file_path.name == 'admin.py':
            if 'admin.site.register' not in content and len(content_stripped) < 200:
                return True

        if file_path.name in ('index.js', 'index.ts', 'index.jsx', 'index.tsx'):
            if content_stripped.startswith('export') and len(content_stripped) < 100:
                return True

        return False

    def _process_content(self, content: str, file_path: Path) -> str:
        """Process content for compactness."""
        if not self.compact_mode:
            return content

        lines = content.split('\n')
        processed_lines = []
        consecutive_empty = 0
        in_docstring = False

        for line in lines:
            stripped = line.strip()

            if '"""' in stripped or "'''" in stripped:
                    processed_lines.append(line)
                    continue
                in_docstring = not in_docstring
                if in_docstring:
                    processed_lines.append(line)
                continue

            if in_docstring:
                continue  # Skip docstring content

            # Skip excessive comments (keep important ones)
            if stripped.startswith('#') or stripped.startswith('//'):
                if any(kw in stripped.lower() for kw in ['todo', 'fixme', 'note:', 'important', 'hack']):
                    processed_lines.append(line)
                continue

            if not stripped:
                consecutive_empty += 1
                if consecutive_empty <= 1:
                    processed_lines.append('')
                continue
            else:
                consecutive_empty = 0

            processed_lines.append(line)

        return '\n'.join(processed_lines)

    def _write_file_section(self, out, rel_path: Path, content: str, size: int) -> None:
        """Write file section in compact format."""
        if self.compact_mode:
            out.write(f"\n### {rel_path}\n")
            out.write(f"```{self._get_language(rel_path)}\n")
            out.write(content.rstrip())
            out.write("\n```\n")
        else:
            out.write(f"\n{'='*60}\n")
            out.write(f"FILE: {rel_path} ({size}B)\n")
            out.write("-" * 60 + "\n")
            out.write(content)
            if not content.endswith('\n'):
                out.write('\n')

    def _get_language(self, path: Path) -> str:
        """Get language for syntax highlighting."""
        ext_map = {
            '.py': 'python',
            '.js': 'javascript',
            '.jsx': 'jsx',
            '.ts': 'typescript',
            '.tsx': 'tsx',
            '.html': 'html',
            '.css': 'css',
            '.scss': 'scss',
            '.json': 'json',
            '.yaml': 'yaml',
            '.yml': 'yaml',
            '.md': 'markdown',
            '.sql': 'sql',
            '.sh': 'bash',
        }
        return ext_map.get(path.suffix.lower(), '')

    def _write_summary(self, out) -> None:
        """Write extraction summary."""
        out.write(f"\n{'='*60}\n")
        out.write("## SUMMARY\n")
        out.write(f"- Files included: {self.stats['included']}\n")
        out.write(f"- Skipped (boilerplate): {self.stats['skipped_boilerplate']}\n")
        out.write(f"- Skipped (size): {self.stats['skipped_size']}\n")
        out.write(f"- Skipped (binary): {self.stats['skipped_binary']}\n")

        if self.skipped_files:
            out.write("\n### Skipped Files:\n")
            for f in self.skipped_files[:50]:  # Limit to 50
                out.write(f"  - {f}\n")
            if len(self.skipped_files) > 50:
                out.write(f"  ... and {len(self.skipped_files) - 50} more\n")

    def _print_stats(self) -> None:
        """Print extraction statistics."""
        print(f"\nâœ… Extracted to: {self.output_file}")
        print(f"ðŸ“ Files included: {self.stats['included']}")
        print(f"â­ï¸  Skipped: {sum(v for k, v in self.stats.items() if k != 'included')}")

        size = Path(self.output_file).stat().st_size
        if size > 1024 * 1024:
            print(f"ðŸ“¦ Output size: {size / (1024*1024):.2f} MB")
        else:
            print(f"ðŸ“¦ Output size: {size / 1024:.2f} KB")

def main():
    import argparse

    parser = argparse.ArgumentParser(
        description="Extract Django + React codebase (smart filtering)"
    )
    parser.add_argument(
        "-d", "--directory", 
        default=".", 
        help="Root directory"
    )
    parser.add_argument(
        "-o", "--output", 
        default="codebase_contents.txt", 
        help="Output file"
    )
    parser.add_argument(
        "--max-size", 
        type=int, 
        default=100, 
        help="Max file size in KB (default: 100)"
    )
    parser.add_argument(
        "--include-tests", 
        action="store_true", 
        help="Include test files"
    )
    parser.add_argument(
        "--include-configs", 
        action="store_true", 
        help="Include config files"
    )
    parser.add_argument(
        "--no-compact", 
        action="store_true", 
        help="Disable compact mode (keep comments/docstrings)"
    )

    args = parser.parse_args()

    extractor = CodebaseExtractor(
        root_dir=args.directory,
        output_file=args.output,
        max_file_size=args.max_size * 1024,
        include_tests=args.include_tests,
        include_configs=args.include_configs,
        compact_mode=not args.no_compact,
    )

    extractor.extract()

if __name__ == "__main__":
    main()
```

### create_analyst_user.py
```python
import os
import django

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'backend.settings')
django.setup()

from api.models import User

username = "analyst"
password = "password"
email = "analyst@example.com"

try:
    user = User.objects.create_user(
        username=username,
        email=email,
        password=password,
        is_staff=True,
        is_superuser=False
    )
    print("\nâœ… User created successfully!")
    print(f"Username: {user.username}")
    print(f"Email: {user.email}")
    print(f"Is Staff: {user.is_staff}")
    print(f"Is Superuser: {user.is_superuser}")
except Exception as e:
    print(f"âŒ Error creating user: {e}")
```

### debug_out_utf8.txt
```
Traceback (most recent call last):
  File "C:\Users\lenovo\Desktop\Dev-Ground\UST\cyb.lib-main\backend\debug_views.py", line 10, in <module>
    from api import views
  File "C:\Users\lenovo\Desktop\Dev-Ground\UST\cyb.lib-main\backend\api\views.py", line 6, in <module>
    from .serializers import (
    ...<4 lines>...
    )
  File "C:\Users\lenovo\Desktop\Dev-Ground\UST\cyb.lib-main\backend\api\serializers.py", line 30, in <module>
    class PathSerializer(serializers.ModelSerializer):
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    ...<2 lines>...
            fields = ["id", "title", "slug", "type"]  # maps to paths table columns [web:86]
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Users\lenovo\Desktop\Dev-Ground\UST\cyb.lib-main\backend\api\serializers.py", line 31, in PathSerializer
    class Meta:
    ^^^^^^^^^^^
        model = Path
        ^^^^^^^^^^^^
        fields = ["id", "title", "slug", "type"]  # maps to paths table columns [web:86]
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Users\lenovo\Desktop\Dev-Ground\UST\cyb.lib-main\backend\api\serializers.py", line 32, in Meta
    model = Path
            ^^^^
NameError: name 'Path' is not defined
```

### debug_views.py
```python
import os
import django
import traceback

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'backend.settings')
django.setup()

try:
    print("Attempting to import api.views...")
    from api import views
    print("Import SUCCESS")
except Exception:
    print("Import FAILED")
    with open('debug_out_utf8.txt', 'w', encoding='utf-8') as f:
        traceback.print_exc(file=f)
    print("Traceback written to debug_out_utf8.txt")
```

### scripts\seed_framework.py
```python
"""

import os
import uuid
import sys
from pprint import pprint

try:
    from dotenv import load_dotenv
    load_dotenv(os.path.join(os.path.dirname(__file__), '..', '.env'))
except Exception:
    pass

DB_CONFIG = {
    "dbname": os.getenv('DB_NAME', 'cybdb'),
    "user": os.getenv('DB_USER', 'postgres'),
    "password": os.getenv('DB_PASSWORD', ''),
    "host": os.getenv('DB_HOST', 'localhost'),
    "port": os.getenv('DB_PORT', '5432'),
}

TAXII_URL = "https://cti-taxii.mitre.org/stix/collections/"  # alternative to attack-taxii

TACTIC_TO_PHASE_MAP = {
    "reconnaissance": 1,
    "resource-development": 2,  # weaponization-ish
    "initial-access": 3,
    "execution": 4,
    "persistence": 5,
    "privilege-escalation": 4,
    "defense-evasion": 5,
    "credential-access": 6,
    "discovery": 1,
    "lateral-movement": 6,
    "command-and-control": 6,
    "exfiltration": 7,
    "impact": 7,
}

TABLE_KILL_CHAIN = 'api_killchainphase'
TABLE_MITRE_TACTIC = 'api_mitretactic'
TABLE_MITRE_TECH = 'api_mitretechnique'
TABLE_TACTIC_PHASE = 'api_tacticphasemap'

def fetch_from_taxii():
    """Fetch STIX objects from MITRE TAXII using taxii2-client and stix2."""
    try:
        from taxii2client.v21 import Server
        from stix2 import TAXIICollectionSource, Filter
    except Exception as e:
        print("Missing dependencies: please install 'taxii2-client stix2' (pip install taxii2-client stix2)")
        raise

    print("Connecting to TAXII server...", TAXII_URL)
    server = Server(TAXII_URL)
    api_roots = server.api_roots
    if not api_roots:
        raise RuntimeError("No API roots from TAXII server")
    api_root = api_roots[0]

    collection = None
    for c in api_root.collections:
        title = getattr(c, 'title', '') or getattr(c, 'id', '')
        if 'Enterprise' in title or 'enterprise-attack' in title.lower():
            collection = c
            break
    if not collection:
        collection = api_root.collections[0]

    src = TAXIICollectionSource(collection)

    tactics = list(src.query(Filter('type', '=', 'x-mitre-tactic')))
    techniques = list(src.query([Filter('type', '=', 'attack-pattern'), Filter('revoked', '!=', True)]))

    print(f"Fetched {len(tactics)} tactics and {len(techniques)} techniques")
    return tactics, techniques

def upsert(db, cursor, sql, params):
    cursor.execute(sql, params)
    try:
        return cursor.fetchone()
    except Exception:
        return None

def seed():
    import psycopg2

    print("Connecting to DB", {k: DB_CONFIG[k] for k in ('dbname','host','port','user')})
    conn = psycopg2.connect(**DB_CONFIG)
    cur = conn.cursor()

    phases = [
        (1, 'Reconnaissance', 'Planning and research.'),
        (2, 'Weaponization', 'Preparation of tools.'),
        (3, 'Delivery', 'Transmission to target.'),
        (4, 'Exploitation', 'Triggering the weapon.'),
        (5, 'Installation', 'Establishing persistence.'),
        (6, 'Command and Control', 'Remote manipulation.'),
        (7, 'Actions on Objectives', 'Data theft or destruction.'),
    ]

    for step, name, desc in phases:
        cur.execute(f"INSERT INTO {TABLE_KILL_CHAIN} (step_number, name, description) VALUES (%s,%s,%s) ON CONFLICT (step_number) DO UPDATE SET name=EXCLUDED.name, description=EXCLUDED.description RETURNING id;", (step, name, desc))
        res = cur.fetchone()
        if res:
            pass

    tactics, techniques = fetch_from_taxii()

    tactic_short_to_dbid = {}

    print("Seeding tactics...")
    for t in tactics:
        mitre_id = None
        for ref in getattr(t, 'external_references', []) or []:
            if getattr(ref, 'source_name', '') == 'mitre-attack' and getattr(ref, 'external_id', None):
                mitre_id = ref.external_id
                break
        if not mitre_id:
            continue
        name = getattr(t, 'name', mitre_id)
        short = getattr(t, 'x_mitre_shortname', None) or (name.lower().replace(' ', '-'))

        cur.execute(f"INSERT INTO {TABLE_MITRE_TACTIC} (id, mitre_id, name) VALUES (%s,%s,%s) ON CONFLICT (mitre_id) DO UPDATE SET name=EXCLUDED.name RETURNING id;", (str(uuid.uuid4()), mitre_id, name))
        dbid = cur.fetchone()[0]
        tactic_short_to_dbid[short] = dbid

        key = (getattr(t, 'x_mitre_shortname', '') or name).lower()
        phase_num = TACTIC_TO_PHASE_MAP.get(key) or TACTIC_TO_PHASE_MAP.get(name.lower())
        if phase_num:
            cur.execute(f"SELECT id FROM {TABLE_KILL_CHAIN} WHERE step_number = %s", (phase_num,))
            row = cur.fetchone()
            if row:
                phase_id = row[0]
                cur.execute(f"INSERT INTO {TABLE_TACTIC_PHASE} (tactic_id, phase_id) VALUES (%s,%s) ON CONFLICT DO NOTHING;", (dbid, phase_id))

    print("Seeding techniques (assigning primary tactic)...")
    for tech in techniques:
        mitre_id = None
        for ref in getattr(tech, 'external_references', []) or []:
            if getattr(ref, 'source_name', '') == 'mitre-attack' and getattr(ref, 'external_id', None):
                mitre_id = ref.external_id
                break
        if not mitre_id:
            continue

        name = getattr(tech, 'name', mitre_id)
        desc = getattr(tech, 'description', '')

        primary_dbid = None

        for kcp in getattr(tech, 'kill_chain_phases', []) or []:
            phase_name = kcp.get('phase_name', '').lower()
            if phase_name in tactic_short_to_dbid:
                primary_dbid = tactic_short_to_dbid[phase_name]
                break
            if phase_name in TACTIC_TO_PHASE_MAP:
                for short, dbid in tactic_short_to_dbid.items():
                    if TACTIC_TO_PHASE_MAP.get(short) == TACTIC_TO_PHASE_MAP[phase_name]:
                        primary_dbid = dbid
                        break
                if primary_dbid:
                    break

        if not primary_dbid:
            x_tactics = getattr(tech, 'x_mitre_tactics', None) or []
            for xt in x_tactics:
                key = xt.lower().replace(' ', '-')
                if key in tactic_short_to_dbid:
                    primary_dbid = tactic_short_to_dbid[key]
                    break

        if not primary_dbid and tactic_short_to_dbid:
            primary_dbid = list(tactic_short_to_dbid.values())[0]

        if primary_dbid:
            cur.execute(f"INSERT INTO {TABLE_MITRE_TECH} (id, mitre_id, name, description, tactic_id) VALUES (%s,%s,%s,%s,%s) ON CONFLICT (mitre_id) DO UPDATE SET name=EXCLUDED.name, description=EXCLUDED.description, tactic_id=EXCLUDED.tactic_id RETURNING id;", (str(uuid.uuid4()), mitre_id, name, desc, primary_dbid))
            try:
                cur.fetchone()
            except Exception:
                pass

    conn.commit()
    cur.close()
    conn.close()
    print("Done seeding MITRE framework data.")

if __name__ == '__main__':
    try:
        seed()
    except Exception as e:
        print('Error:', e)
        sys.exit(1)
```

============================================================
## SUMMARY
- Files included: 19
- Skipped (boilerplate): 7
- Skipped (size): 0
- Skipped (binary): 1

### Skipped Files:
  - .env (boilerplate)
  - api\admin.py (boilerplate content)
  - api\apps.py (boilerplate)
  - api\tests.py (test file)
  - backend\asgi.py (boilerplate)
  - backend\wsgi.py (boilerplate)
  - codebase_contents.txt (boilerplate)
  - debug_output.txt (binary)
  - manage.py (boilerplate)
  - test_api.py (test file)
  - test_lessons_with_techniques.py (test file)
  - test_navigator.py (test file)
  - test_nested_data.py (test file)
